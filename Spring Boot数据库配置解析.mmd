Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot数据库配置
- NOTE
<pre>Spring Boot对主流的数据库都提供了很好的支持，打开Spring Boot项目中的starters会发现针对
data提供了15个starter的支持，包含了大量的关系型数据库和非关系数据库的数据访问解决方案。
而本章重点关注Spring Boot中数据源自动配置源码的实现，及核心配置类
DataSourceAutoConfiguration和JdbcTemplateAutoConfiguration等的用法。</pre>

## 自动配置注解解析
- NOTE
<pre>数据源的自动配置像其他自动配置一样，在META-INF/spring.factories文件中注册了对应自动配置类。
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {
}
注解@ConditionalOnClass要求类路径下必须有DataSource和EmbeddedDatabaseType类的存在。
@EnableConfigurationProperties属性会装配DataSourceProperties类，该配置类与
application.properties中的配置相对应。
比如，对于数据库我们经常在application.properties中做如下的配置。
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
在DataSourceProperties类中都有对应的属性存在。
@Import注解引入了两个自动配置类DataSourcePoolMetadataProvidersConfiguration和
DataSourceInitializationConfiguration。

配置类DataSourcePoolMetadataProvidersConfiguration中定义了3个静态内部类，
用于定义3个DataSource的DataSourcePoolMetadataProvider的初始化条件。其中包括tomcat的
DataSource、HikariDataSource和BasicDataSource。默认使用HikariDataSource。

我们以tomcat的DataSource为例，看一下源代码。
@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)
	static class TomcatDataSourcePoolMetadataProviderConfiguration {

		@Bean
		DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {
			return (dataSource) -&gt; {
				org.apache.tomcat.jdbc.pool.DataSource tomcatDataSource = DataSourceUnwrapper.unwrap(dataSource,
						org.apache.tomcat.jdbc.pool.DataSource.class);
				if (tomcatDataSource != null) {
					return new TomcatDataSourcePoolMetadata(tomcatDataSource);
				}
				return null;
			};
		}

	}
内部类中判断classpath是否存在tomcat的DataSource，如果存在，则实例化并注册一个
DataSourcePoolMetadataProvider，其中Lambda表达式为DataSourcePoolMetadataProvider的
getDataSourcePoolMetadata方法的具体实现。
DataSourcePoolMetadataProvider的作用是基于DataSource提供一个DataSourcePoolMetadata，
该接口只提供了一个对应的方法。

下面我们再来看自动配置代码中DataSourcePoolMetadataProvider接口方法的实现逻辑。首先，
通过DataSourceUnwrapper的unwrap方法获得一个DataSource数据源；
然后判断数据源是否为null，如果不为null，则返回一个TomcatDataSourcePoolMetadata对象，
如果为null，则返回null。
DataSourceUnwrapper类的主要作用是提取被代理或包装在自定义Wrapper（如
DelegatingDataSource）中的数据源。

当获取DataSource对象之后，便直接创建TomcatDataSourcePoolMetadata类的对象，
该类是针对Tomcat数据源的DataSourcePoolMetadata具体实现的。
针对DataSourcePoolMetadata接口方法的具体实现，都是围绕着DataSource对象中存储的数据源
信息展开的。DataSourcePoolMetadata接口提供了大多数数据库都提供的元数据的方法定义。
public interface DataSourcePoolMetadata {

	/**
	 * 返回当前数据库连接池的情况，返回值在0到1之间
	 * 1：已分配最大连接数
	 * 0：当前没有连接处于活跃状态
	 * -1：可以分配的连接数没有限制
	 * null：当前数据源不提供必要信息进行计算
	 */
	Float getUsage();

	/**
	 * 返回当前已分配的活跃连接数，返回null，则表示该信息不可用
	 */
	Integer getActive();

	/**
	 * 
	 */
	default Integer getIdle() {
		return null;
	}

	/**
	 * 返回同时可分配的最大活跃连接数，返回-1表示不受限制，返回null，则表示该信息不可用
	 */
	Integer getMax();

	/**
	 * 返回连接池中最小空闲连接数，返回null，则表示该信息不可用
	 */
	Integer getMin();

	/**
	 * 返回查询以验证连接是否有效，返回null，则表示该信息不可用
	 */
	String getValidationQuery();

	/**
	 * 连接池创建的连接默认是自动提交状态。如果未将其设置为null，则默认采用JDBC驱动，
	 * 如果设置为null，则方法java.sql.Connction.setAutoCommit(boolean);将不会被调用
	 */
	Boolean getDefaultAutoCommit();

}

讲解完了DataSourcePoolMetadataProvidersConfiguration，下面再看另外一个引入的配置类
DataSourceInitializationConfiguration，它主要的功能是配置数据源的初始化。
DataSourceInitializationConfiguration同样分两部分：注解引入和内部实现。
首先看引入的DataSourceInitializerInvoker，该类实现了ApplicationListener接口和
InitializingBean接口，也就是说，它同时具有事件监听和执行自定义初始化的功能。
DataSourceInitializerInvoker构造方法被调用时会传入数据源、数据源配置和ApplicationContext
信息，并赋值给对应的属性。
由于DataSourceInitializerInvoker实现了InitializingBean接口，当BeanFactory设置完属性之后，
会调用afterPropertiesSet方法来完成自定义操作。
@Override
	public void afterPropertiesSet() {
		DataSourceInitializer initializer = getDataSourceInitializer();
		if (initializer != null) {
			boolean schemaCreated = this.dataSourceInitializer.createSchema();
			if (schemaCreated) {
				initialize(initializer);
			}
		}
	}
在afterPropertiesSet中重点做了DataSourceInitializer的实例化和初始化操作。其中
DataSourceInitializer的实例化比较简单，就是根据数据源、配置属性和ApplicationContext
创建了一个对象，并将对象赋值给DataSourceInitializerInvoker的属性。

完成了DataSourceInitializer的初始化，后续的操作便是调用其提供的方法进行初始化操作。
比如上面代码中调用createSchema方法来执行DDL语句（schema-*.sql）就是进行初始化操作。
值得注意的是，afterPropertiesSet方法中还调用了initialize方法，initialize方法中首先发布了一个
DataSourceSchemaCreatedEvent事件。然后，为了防止在发布事件时对应的监听并未注册，
在发布完事件之后，主动做了监听事件中要做的事。
而对应的监听事件，同样定义在DataSourceInitializerInvoker类中，上面我们已经得知它实现了
ApplicationListener接口，监听的便是上面发布的事件。onApplicationEvent方法中的实现与
initialize方法的实现基本相同（除了发布事件操作）。

这里稍微拓展一下DataSourceInitializer的两个方法createSchema和initSchema：
createSchema方法和initSchema方法都是获取指定位置或类路径中的SQL（.sql）文件，然后再获得
用户名和密码，最后执行SQL文件中的脚本。这两个方法不同之处在于：createSchema常用于初始化建
表语句；initSchema常用于插入数据及更新数据操作。
在方法中也可以看到，可在application.properties文件中进行如下配置来指定其SQL文件位置。
spring.datasource.schema=classpath:schema-my-mysql.sql
spring.datasource.schema=classpath:data-my-mysql.sql
</pre>

## 自动配置内部实现解析
> leftSide=`true`

- NOTE
<pre>DataSourceAutoConfiguration中共有5个静态内部类，包括
EmbeddedDatabaseConfiguration和PooledDataSourceConfiguration两个声明有
@Configuration注解的自动配置类，以及另外3个限制条件类：PooledDataSourceCondition、
PooledDataSourceAvailableCondition、Em-beddedDatabaseCondition。</pre>

### EmbeddedDatabaseConfiguration
- NOTE
<pre>该类其实并没有方法实现，它的主要功能是通过@Import引入类来完成，
@Configuration(proxyBeanMethods = false)
	@Conditional(EmbeddedDatabaseCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import(EmbeddedDataSourceConfiguration.class)
	protected static class EmbeddedDatabaseConfiguration {

	}
@Conditional使用了DataSourceAutoConfiguration的内部类EmbeddedDatabaseCondition来
进行条件判断。EmbeddedDatabaseCondition主要用来检测何时可以使用内嵌DataSource，
如果已经存在池化（pooled）的DataSource，该类则不会被实例化，优先选择池化DataSource。
</pre>

### PooledDataSourceConfiguration
- NOTE
<pre>除了支持内嵌的DataSource，Spring Boot还支持一些实现Pool的DataSource。
目前支持com.zaxxer.hikari.Hikari-DataSource、org.apache.tomcat.jdbc.pool.DataSource和
org.apache.commons.dbcp2.BasicDataSource这3种DataSource。
而性能更加优秀的HikariDataSource作为了Spring Boot中的默认选项。
@Configuration(proxyBeanMethods = false)
	@Conditional(PooledDataSourceCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,
			DataSourceJmxConfiguration.class })
	protected static class PooledDataSourceConfiguration {

	}
PooledDataSourceConfiguration中同样没有具体实现。@Conditional的筛选条件也是由内部类
PooledDataSourceCondition来完成的，这些内容前面已经讲过，这里不再赘述。
该实例化对象的优先级要高于内嵌DataSource的。
我们重点看@Import引入的前4个类，它们是DataSourceConfiguration的内部类，提供了
Hikari、Tomcat、Dbcp2、Generic的DataSource配置。DataSourceConfiguration就是用于
DataSourceAutoConfiguration导入的实际的DataSource配置，这里我们以Hikari为例来进行讲解。
Hikari是spring-boot-starter-jdbc默认引入的数据源。
@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,
			matchIfMissing = true)
	static class Hikari {

		@Bean
		@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)
		HikariDataSource dataSource(DataSourceProperties properties) {
			HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class);
			if (StringUtils.hasText(properties.getName())) {
				dataSource.setPoolName(properties.getName());
			}
			return dataSource;
		}

	}
@ConditionalOnClass指定必须在classpath中存在HikariDataSource才会进行实例化操作。
而该类由spring-boot-starter-jdbc默认将其引入，因此当引入该starter时，只有Hikari的自动配置
满足条件，会被实例化。
@ConditionalOnProperty注解可以通过在application.properties文件中配置key为
spring.datasource.type，值为com.zaxxer.hikari.HikariDataSource的配置项用来明确启动使用
Hikari数据源。matchIfMissing为true，说明如果没有配置则默认操作生效。
</pre>

## JdbcTemplateAutoConfiguration
> leftSide=`true`

- NOTE
<pre>在实践过程中，除了数据源的配置外，我们还会经常用到JdbcTemplate。JdbcTemplate是
Spring对数据库jdbc操作的封装。
JdbcTemplate的自动配置是通过JdbcTemplateAutoConfiguration来完成的，与
DataSourceAutoConfiguration的自动配置在spring.factories中注册位置一样。
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration

@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })
@ConditionalOnSingleCandidate(DataSource.class)
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
@EnableConfigurationProperties(JdbcProperties.class)
@Import({ JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })
public class JdbcTemplateAutoConfiguration {

}

JdbcTemplateAutoConfiguration导入的NamedParameterJdbcTemplateConfiguration主要用来初始化
NamedParameterJdbcTemplate。NamedParameterJdbcTemplate相当于JdbcTemplate的包装类，
提供了基于占位符的SQL的功能。
无论是JdbcTemplate还是NamedParameterJdbcTemplate的实例化，注解部分都添加了
@Primary，用来表示当存在多个同类型的对象时，当前对象会被优先注入。
</pre>

## 异常案例分析
- NOTE
<pre>Spring Boot中大多数自动配置引入之后不需要用户操作什么便可自动生效，但是数据源的配置算是
一个例外。如果只是引入了spring-boot-starter-jdbc这个starter，启动的时候是会抛出异常的。
这是为什么呢？这是因为如果引入了该starter，等于变相引入了spring-jdbc，而数据源自动化配置
类DataSourceAutoConfiguration生效的限定条件为classpath中同时存在javax.sql.DataSource和
org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType。两个条件都满足，
数据源自动配置生效，开始初始化相关信息。而此时，在application.properties中如果没有配置连接
数据库的相关配置，便会抛出异常。
针对此异常，如果暂时不考虑使用数据库连接，可去掉spring-boot-starter-jdbc的依赖，或明确声明
排除DataSourceAutoConfiguration的自动配置。可通过注解或配置文件两种形式中的一种
来达到目的。
在启动类上添加注解排除方式。
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
通过配置文件排除方式。
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</pre>
