Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot Web
- NOTE
<pre>在Spring及Spring Boot的使用过程中，应用最广泛的当属Web应用，而Web应用又往往部署在
像Tomcat这样的Servlet容器中。本章将带领大家学习Spring Boot中Web应用的整合以及在此过程
中与直接使用Spring的差别。</pre>

## 遗失的web\.xml
- NOTE
<pre>提到Spring的Web应用，我们首先想到的可能是Spring MVC框架和web.xml等配置文件。
而Spring MVC又是围绕DispatcherServlet这个核心类来展开的。Spring Boot当前是基于
Spring 5.2.x版本，和传统的Spring启动有所不同。以前是通过在web.xml中配置Servlet来完成
Spring MVC的启动，但在SpringBoot中是通过DispatcherServletAutoConfiguration来完成
初始化工作的。在此过程中，web.xml遗失了。

我们先回顾一下Servlet 3.0之前版本的操作。当我们创建一个web项目时，往往会在
resources/WEB-INF目录下创建一个web.xml文件，该文件内配置了Servlet和Filter等功能。
当Spring MVC出现后，web.xml中便有了DispatcherServlet的配置。

随着Java EE 6的发布，Servlet 3.0作为Java EE 6规范体系的一员，也被慢慢推广并被用户接受。
Servlet 3.0在Servlet 2.5的基础上提供了一些简化Web应用的开发和部署的新特性，无xml配置便
是其中一项。
Servlet 3.0提供了@WebServlet、@WebFilter等注解，可以使用注解来声明Servlet和Filter，
这便有了抛弃web.xml的基础。同时，它还提供了可以在运行时动态注册Servlet、Filter、Listener
等更加强大的功能。
在Servlet 3.0中还新增了ServletContainerInitializer接口，在容器启动时使用JAR服务API来发现其实
现类，并将容器WEB-INF/lib目录下jar包中的类都交由该类的onStartup方法来处理。而Servlet和
Filter在Web应用启动时可借助该接口的实现类和Java的SPI机制完成加载。

在Spring中提供了ServletContainerInitializer接口的实现类SpringServletContainerInitializer，
该类在其onStartup方法中会调用所有WebApplicationInitializer实现类的onStartup方法，
将相关组件注册到容器中。而Servlet和Filter也是通过WebApplicationInitializer的实现类完成创建
和加载的。基于以上新特性和演变，当我们使用Spring Boot时，Spring Boot已经不知不觉地开始
使用这些新特性了。至此，我们从发展的角度了解了web.xml消失的过程。</pre>

## Web应用的自动配置
> leftSide=`true`

- NOTE
<pre>在Spring Boot项目中引入spring-boot-starter-web的依赖，Spring Boot的自动配置机制便会加载
并初始化其相关组件。Servlet 3.0中新增了ServletContainerInitializer接口，而在Spring中又提供了
其实现类SpringServletContainerInitializer来初始化Servlet。但在Spring Boot中，当引入
spring-boot-starter-web的依赖之后，Spring Boot并未完全遵守Servlet 3.0的规范，
也没有使用Spring中提供的SpringServletContainerInitializer类，而是完全选择另外一套初始化流程。

根据自动配置的原理，我们在spring-boot-autoconfigure包中的META-INF/spring.factories配置
文件中找到了针对Servlet自动配置的EnableAutoConfiguration：
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration

下面对EnableAutoConfiguration类中的自动配置项目进行逐步分析：
1、DispatcherServlet自动配置
DispatcherServlet自动配置位于DispatcherServletAutoConfiguration类中。下面我们通过
DispatcherServletAutoConfiguration的源码来了解其自动配置的过程。
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {
......
}
注解的作用如下：
·@AutoConfigureOrder：指定自动配置加载的顺序。
·@Configuration：指定该类为配置类，交给Spring容器管理，默认指定不使用代理。
·@ConditionalOnWebApplication：表示只有Web应用才会加载此类。
·@ConditionalOnClass：表示只有存在DispatcherServlet类的情况下才会加载此类。
·@AutoConfigureAfter：ServletWebServerFactoryAutoConfiguration类加载完成之后才会加载
此类。

从整体上来看，在DispatcherServletAutoConfiguration内部主要提供了4个静态内部类。
·DispatcherServletConfiguration：主要用来初始化DispatcherServlet。
·DispatcherServletRegistrationConfiguration：主要用来将DispatcherServlet注册到系统中。
·DefaultDispatcherServletCondition：主要针对容器中DispatcherServlet进行一些逻辑判断。
·DispatcherServletRegistrationCondition：主要针对注册DispatcherServlet进行一些逻辑判断。

通过DispatcherServletConfiguration的源码可以看出，当满足指定的条件后，会对
DispatcherServletConfiguration进行实例化，而该类内部被@Bean注解的方法会被实例化，
生成Bean并注入Spring容器中。其中，在DispatcherServlet方法中完成了DispatcherServlet的
实例化和基本设置。这里既没有用到SPI机制，也没用到Spring提供的
SpringServletContainerInitializer和Servlet 3.0的ServletContainerInitializer接口。
DispatcherServlet方法将DispatcherServlet实例化的Bean注入Spring容器中，并且指定Bean的
name为dispatcherServlet。该名称默认会被映射到根URL的/访问路径。
DispatcherServlet作为前端控制器设计模式的实现，提供了Spring WebMVC的集中访问点，
负责职责的分派，与Spring Ioc容器无缝集成，可以获得Spring的所有好处。它的主要作用包括：
文件上传解析、请求映射到处理器、通过ViewResolver解析逻辑视图名到具体视图实现、
本地化解析、渲染具体视图等。

在未使用Spring Boot时，通常DispatcherServlet类的配置需要开发人员在web.xml当中进行配置。
这里Spring Boot通过自动配置完成了DispatcherServlet类的配置和初始化，并在此过程中设置了
一些初始化的参数。这些参数通过HttpProperties和WebMvcProperties获得。

DispatcherServletConfiguration中还定义了上传文件的解析器MultipartResolver的Bean初始化
操作，准确来说是Bean名称转化的操作。通过条件注解判断，当MultipartResolver的Bean存在，
但Bean的名称不为“multipartResolver”时，将其重命名为“multipartResolver”。

DefaultDispatcherServletCondition的最核心业务逻辑只做了一件事，那就是：防止重复生成
DispatcherServlet。具体实现流程为：从上下文中获得beanFactory，然后通过beanFactory获取
类型为DispatcherServlet的Bean的name列表，然后分别判断name列表和beanFactory中是否包含
名称为“dispatcherServlet”的字符串或Bean，如果包含则返回不匹配（已经存在，不匹配则不会
重复实例化），否则返回匹配。

DispatcherServletConfiguration类中还有一个注解@EnableConfigurationProperties，该注解
指定了两个配置类：HttpProperties和WebMvcProperties。这两个配置类正是上面初始化
DispatcherServlet时用于初始化的参数值，查看这两个类的源代码就会发现，它们分别对应加载了
以“spring.http”和“spring.mvc”为前缀的配置项，可以在application.properties文件中进行配置。


2、DispatcherServletRegistrationBean自动配置
DispatcherServletRegistrationConfiguration类的核心功能就是注册dispatcherServlet，使其生效
并设置一些初始化的参数。其中，DispatcherServletRegistrationBean继承自
ServletRegistrationBean，主要为DispatcherServlet提供服务。
DispatcherServletRegistrationBean和DispatcherServlet都提供了注册Servlet并公开
DispatcherServletPath信息的功能。
在dispatcherServletRegistration方法中直接通过new来创建DispatcherServletRegistrationBean，
第一个参数为DispatcherServlet，第二个参数为application配置文件中配置的path值。
在DispatcherServletRegistrationBean中实现了setUrlMappings和addUrlMappings两种方法，
但均直接抛出异常，这相当于禁用了该子类中这两项操作。而在构造方法中除了成员变量赋值之外，
还调用了父类ServletRegistrationBean的构造方法
ServletRegistrationBean(Tservlet,String...urlMappings)和
addUrlMappings(String...urlMappings)方法。
关于ServletRegistrationBean的构造方法和addUrlMappings只是进行成员变量的赋值和设置，
我们重点看DispatcherServletRegistrationBean在构造方法中调用的getServletUrlMapping方法。
顾名思义，该方法的功能是获取Servlet的URL的匹配。该方法具体在
DispatcherServletRegistrationBean实现的接口DispatcherServletPath中定义。
DispatcherServletPath的主要功能是提供自动配置所需的path信息，而
DispatcherServletRegistrationBean中的path信息正是构造方法传入的。
getServletUrlMapping方法为接口的默认实现方法，返回一个用于
ServletRegistrationBean映射DispatcherServlet的URL表达式。判断逻辑比较简单：如果获得的
path为空或“/”，则返回“/”；如果path中包含“*”，则直接返回path；如果path以“/”结尾，则对
path后追加“*”；其他情况下，path后面追加“/*”。





</pre>

## Spring MVC的自动配置
> leftSide=`true`

- NOTE
<pre>在Spring Boot中引入了spring-boot-starter-web依赖，并完成了DispatcherServlet的自动配置之后，
便会通过WebMvcAutoConfiguration进行Spring MVC的自动配置。
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
......
}
Spring MVC在自动配置中的代码较多，官方文档中重点提到了以下功能的实现：
·定义ContentNegotiatingViewResolver和BeanNameViewResolver的Bean。
·对静态资源的支持，包括对WebJars的支持。
·自动注册Converter、GenericConverter、Formatter的Bean。
·对HttpMessageConverters的支持。
·自动注册MessageCodeResolver。
·对静态index.html的支持。
·使用ConfigurableWebBindingInitializer的Bean。
当然，在自动配置类中不只包括了以上的功能实现，还包括其他功能，这里就不一一列举了。
下面会挑选几个有代表性的功能进行源代码及实例化过程的分析：
1、ViewResolver解析
这里以ContentNegotiatingViewResolver和BeanNameViewResolver的bean的实例化为例进行相应解析。

ContentNegotiatingViewResolver实例化比较简单，创建对象，设置请求资源类型管理器为
ContentNegotiationManager，并设置优先级。需要注意的是，要让
ContentNegotiatingViewResolver正常工作，需要设置更高的优先级（默认为
Ordered.HIGHEST_PRECEDENCE）。ContentNegotiatingViewResolver类实现了
ViewResolver，但它并不直接解析视图，而是委托给其他解析器来完成。默认情况，它是从
Spring上下文查找视图解析器，并调用这些解析器。也可以在初始化该类时通过
setViewResolvers方法设置解析器属性（viewResolvers）。在此，默认的实例化操作中并没有对
SetViewResolvers方法进行设置。
BeanNameViewResolver主要通过逻辑视图名称匹配定义好的视图Bean对象。一般情况下，对应的
Bean对象需要注册到Spring的上下文中，BeanNameViewResolver会返回名称匹配的视图对象。
BeanNameViewResolver实例化的前提条件是容器中View实现类的Bean存在。
BeanNameViewResolver的resolveViewName方法首先通过名称判断对应视图是否存在，当通过
名称无法匹配时，会通过类型进行视图判断，如果存在对应的Bean，则获取对应的View对象并返回。

2、静态资源的支持
前端页面往往需要访问到静态资源，Spring Boot对静态资源（比如图片、CSS、JS等）的支持，
也包括对webjars的支持，主要是通过实现接口WebMvcConfigurer的addResource-Handlers方法
来完成的。WebMvcConfigurer的接口实现类为WebMvcAutoConfiguration的内部类，这样设计
的主要目的是确保WebMvcConfigurer不在类路径中时不会读取WebMvcConfigurer的实现类。
这里的内部实现类为WebMvcAutoConfigurationAdapter。
而我们要讲的对静态资源的支持便是通过WebMvcAutoConfigurationAdapter实现接口
WebMvcConfigurer的addResourceHandlers方法来完成的。
addResourceHandlers方法中重点进行了webjars资源路径和静态资源路径等默认值的初始化。
首先，如果判断当前ResourceHandlerRegistry中不存在“/webjars/**”，则设置webjars的资源路径
和缓存配置为默认值；其次，判断当前ResourceHandlerRegistry是否存在
“/**”（getStaticPathPattern方法获得的默认值）映射，如果不存在，则使用默认的映射路径、
资源路径和缓存配置。默认的静态资源映射路径在ResourceProperties类中定义，在上面的代码中
是由resourceProperties的getStaticLocations()方法获得。

从ResourceProperties的源码可以看出，Spring Boot默认会加载
classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、
classpath:/public/路径下的静态资源。这是“约定”的一部分，也是为什么我们在实践中默认会将
静态资源都放置在以上路径下。

3、静态index.html
当Spring Boot的web项目启动时，会寻找默认的欢迎页面。下面我们来看Spring Boot默认对
静态index.html的支持是如何实现的。
该功能是在内部类EnableWebMvcConfiguration中通过WelcomePageHandlerMapping来实现的。
主要用来查找默认路径下的index.html（或index模板）页面，并展示默认的欢迎页面。
WelcomePageHandlerMapping本身就是为欢迎页面量身定做的，实现了抽象类
AbstractUrlHandlerMapping。该类的构造方法接收以下4个参数。
·TemplateAvailabilityProviders：TemplateAvailabilityProvider的Bean的集合，可用于检查哪些
（如果有）模板引擎支持给定的视图。默认支持缓存响应，除非将spring.template.provider.cache
属性设置为false。
·ApplicationContext：为应用程序提供配置的控制接口。在应用程序运行时，它是只读的，但是如果
实现类支持，则可以重新加载。
·Optional：index.html对应的Resource，主要通过上述代码中的getWelcome-Page方法获得。
·String staticPathPattern：静态资源路径表达式，默认为“/**”，值定义于WebMvc-Properties中。
WelcomePageHandlerMapping的构造方法中处理了两个分支判断：当index.html资源存在，
并且静态资源路径为“/**”时，设置RootView的名称为“forward:index.html”。也就是说会跳转到
index.html页面。如果不满足上述情况，再判断是否存在欢迎模板页面，如果存在，则设置
RootView为index。另外，在获取WelcomePageHandlerMapping的Optional&lt;Resource&gt;参数时，
默认会在classpath:/META-INF/resources/、classpath:/resources/、classpath:/static/、
classpath:/public/路径下去寻找index.html作为欢迎页面。这些路径的定义同样位于上节提到的
ResourceProperties类中。如果有多个index.html文件存在于以上路径中，它们的优先级按照上面
路径的顺序从高到低排列。
</pre>

## 综合实战
- NOTE
<pre>关于Web方面的配置比较多，值得庆幸的是，Spring Boot已经帮我们预置初始化了很多基础组件。
但在实践的过程中，某些基础的组件并不能满足我们的实际需求，这时就需要我们重新初始化相应组件，
甚至在某些极端的情况下需要完全接管Spring Boot的默认配置。

本实例涉及集成Thymeleaf、自定义初始化ThymeleafViewResolver以及扩展Spring MVC。
Thymeleaf是一个Java类库，能够处理HTML/HTML5、XML、JavaScript、CSS，甚至纯文本类型的
文件。通常可以用作MVC中的View层，它可以完全替代JSP。该框架是Spring Boot首推的前端展示框架。

当集成Thymeleaf之后，Thymeleaf对应的自动配置类ThymeleafAutoConfiguration中会初始化一个
ThymeleafViewResolver，用来对Thymeleaf的页面进行解析和渲染。这一操作本质上同默认的
BeanNameViewResolver作用一样，都实现了ViewResolver接口。此时，如果官方提供的
ThymeleafViewResolver的默认设置无法满足我们的需求，可以通过两种途径进行自定义设置：
通过application配置文件配置和自行创建ThymeleafViewResolver对象。
通过application配置对应的属性定义位于ThymeleafProperties类中，我们已经做过多次类似的配置，
不再赘述。
我们可以通过以下方式自行创建ThymeleafViewResolver对象。
先定义一个配置类ViewResolverConfig，并在类内部通过@Bean注解对实例化的
ThymeleafViewResolver对象进行注入容器的操作。

@Bean默认会将方法thymeleafViewResolver作为Bean的key，将返回的Thymeleaf-ViewResolver
对象作为Value存入容器当中。在方法内部，可通过ThymeleafViewResolver对应的方法进行属性的
初始化设置。通过以上代码我们便完成了自定义ThymeleafViewResolver的注入。
那么，原来默认的ThymeleafViewResolver会怎么处理呢？我们知道几乎所有的自动配置类都是
通过注解设置初始化条件的，比如ThymeleafViewResolver默认实例化的条件是当容器中不存在
名称为thymeleafViewResolver时才会使用默认的初始化。当自定义的ThymeleafViewResolver类
完成初始化之后，默认配置的初始化条件便不再满足了。 

通过WebMvcConfigurer接口实现自定义配置是Spring内部的一种配置方式，它替代了传统的
XML形式的配置。通过对该接口具体方法的实现，可以自定义一些Handler、Interceptor、
ViewResolver、MessageConverter等参数。以上面配置ThymeleafViewResolver为例，
我们也可以通过实现该接口的configureViewResolvers方法来进行配置，达到同样的效果
参考：MyMvcConfig
使用WebMvcConfigurer接口时需注意Spring Boot版本，以上代码是基于Spring Boot 2.0以后的版本。

最后，关于SpringMVC自定义配置的最彻底操作就是完全接管Spring Boot关于SpringMVC的默认
配置，具体操作就是在WebMvcConfigurer的实现类上使用@EnableWebMvc注解
@EnableWebMvc
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
        resolver.setCharacterEncoding(&quot;UTF-8&quot;);
        resolver.setCache(false);
        registry.viewResolver(resolver);
    }
}
使用该注解等于扩展了WebMvcConfigurationSupport，但是没有重写任何方法，因此所需的功能
都需要开发人员自行实现。一般情况下不推荐使用这种方式，该方式更适合基于Spring Boot提供的
默认配置，针对特别需求进行有针对性拓展的场景。

</pre>
