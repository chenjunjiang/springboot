Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot构造流程
- NOTE
<pre>启动流程源码：
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
		this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}</pre>

## SpringApplication
- NOTE
<pre>在SpringApplication对象实例化的过程中主要做了3件事：参数赋值给成员变量、
应用类型及方法推断和ApplicationContext相关内容加载及实例化。

SpringApplication的核心构造方法有两个参数，第一个为ResourceLoaderresourceLoader，
第二个为Class&lt;?&gt;...primarySources。ResourceLoader为资源加载的接口，
在Spring Boot启动时打印对应的banner信息，默认采用的就是DefaultResourceLoader。
实战过程中，如果程序未按照Spring Boot的“约定”将banner的内容放置于classpath下，
或者文件名不是banner.*格式，默认资源加载器是无法加载到对应的banner信息的，
此时可通过ResourceLoader来指定需要加载的文件路径。

第二个参数Class&lt;?&gt;...primarySources，为可变参数，默认传入Spring Boot入口类。如果作为项目的引导类，
此参数传入的类需要满足一个条件，就是被注解@EnableAutoConfiguration或其组合注解标注。
由于@SpringBootApplication注解中包含了@EnableAutoConfiguration注解，
因此被@SpringBootApplication注解标注的类也可作为参数传入。
当然，该参数也可传入其他普通类。但只有传入被@EnableAutoConfiguration标注的类才能够
开启Spring Boot的自动配置。

决定Spring Boot启动的入口类并不一定是main方法所在类，
而是直接或间接被@EnableAutoConfiguration标注的类。
在此也证明了之前提到的@SpringBootApplication和@EnableAutoConfiguration入口
并没有依赖关系，只是无论通过new创建SpringApplication对象再调用run方法或
是通过SpringApplication的run方法来启动程序，都不离不开primarySources参数。</pre>

## Web应用类型推断
> leftSide=`true`

- NOTE
<pre>完成变量赋值之后，在SpringApplication的构造方法中便调用了WebApplicationType的deduceFromClasspath
方法来进行Web应用类型的推断。

WebApplicationType为枚举类，它定义了可能的Web应用类型，该枚举类提供了三类定义：
枚举类型、推断类型的方法和用于推断的常量。枚举类型包括非Web应用、
基于SERVLET的Web应用和基于REACTIVE的Web应用。

·当DispatcherHandler存在，并且DispatcherServlet和ServletContainer都不存在，
则返回类型为WebApplicationType.REACTIVE。·当SERVLET或
ConfigurableWebApplicationContext任何一个不存在时，说明当前应用为非Web应用，
返回WebApplicationType.NONE。·当应用不为REACTIVE Web应用，
并且SERVLET和ConfigurableWebApplicationContext都存在的情况下，
则为SERVLET的Web应用，返回WebApplicationType.SERVLET。</pre>

## ApplicationContextInitializer加载
> leftSide=`true`

- NOTE
<pre>ApplicationContextInitializer是Spring IOC容器提供的一个接口，它是一个回调接口，
主要目的是允许用户在ConfigurableApplicationContext类型（或其子类型）
的ApplicationContext做refresh方法调用刷新之前，对ConfigurableApplicationContext实例做进
一步的设置或处理。通常用于应用程序上下文进行编程初始化的Web应用程序中。

ApplicationContextInitializer接口只定义了一个initialize方法，ApplicationContextInitializer接口
的initialize方法主要是为了初始化指定的应用上下文。而对应的上下文由参数传入，
参数为ConfigurableApplicationContext的子类。在完成了Web应用类型推断之后，
ApplicationContextInitializer便开始进行加载工作，该过程可分两步骤：
获得相关实例和设置实例。对应的方法分别为getSpringFactoriesInstances和setInitializers。
getSpringFactoriesInstances方法依然是通过SpringFactoriesLoader类的loadFactoryNames方法
来获得META-INF/spring.factories文件中注册的对应配置。
完成获取配置类集合和实例化操作之后，调用setInitializers方法将实例化的集合添加到
SpringApplication的成员变量initializers中。
</pre>

## ApplicationListener加载
- NOTE
<pre>完成了ApplicationContextInitializer的加载之后，便会进行ApplicationListener的加载。
它的常见应用场景为：当容器初始化完成之后，需要处理一些如数据的加载、初始化缓存、
特定任务的注册等操作。而在此阶段，更多的是用于ApplicationContext管理Bean过程的场景。

Spring事件传播机制是基于观察者模式（Observer）实现的。
比如，在ApplicationContext管理Bean生命周期的过程中，会将一些改变定义为事件
（ApplicationEvent）。ApplicationContext通过ApplicationListener监听ApplicationEvent，
当事件被发布之后，ApplicationListener用来对事件做出具体的操作。

ApplicationListener的整个配置和加载流程与ApplicationContextInitializer完全一致，
也是先通过SpringFactoriesLoader的loadFactoryNames方法获得META-INF/spring.factories
中对应配置，然后再进行实例化，最后将获得的结果集合添加到SpringApplication的成员变量listeners中。

ApplicationListener接口和ApplicationEvent类配合使用，可实现ApplicationContext的事件处理。
如果容器中存在ApplicationListener的Bean，当ApplicationContext调用publishEvent方法时，
对应的Bean会被触发。这就是观察者模式的实现。
在接口ApplicationListener中只定义了一个onApplicationEvent方法，当监听事件被触发时，onApplicationEvent方法会被执行

onApplicationEvent方法一般用于处理应用程序事件，参数event为ApplicationEvent的子类，是具体响应（接收到）的事件。
当ApplicationContext被初始化或刷新时，会触发ContextRefreshedEvent事件。

在具体的实战业务中，我们也可以自定义事件，在完成业务之后手动触发对应的事件监听器，
也就是手动调用ApplicationContext的publishEvent(ApplicationEvent event)方法。
</pre>

## 入口类推断
> leftSide=`true`

- NOTE
<pre>创建SpringApplication的最后一步便是推断入口类，我们通过调用自身的
deduce-MainApplicationClass方法来进行入口类的推断。

该方法实现的基本流程就是先创建一个运行时异常，然后获得栈数组，遍历栈数组，
判断类的方法中是否包含main方法。第一个被匹配的类会通过Class.forName方法创建对象，
并将其被返回，最后在上层方法中将对象赋值给SpringApplication的成员变量mainApplicationClass。在遍历过程中如果发生异常，会忽略掉该异常并继续执行遍历操作。至此，整个SpringApplication类的实例化过程便完成了。

</pre>

## SpringApplication的定制化配置
- NOTE
<pre>Spring Boot启动过程中构建SpringApplication所做的一系列初始化操作，这些操作都是
Spring Boot默认配置的。如果在此过程中需要定制化配置，Spring Boot在SpringApplication类
中也提供了相应的入口。但正常情况下，如果无特殊需要，采用默认配置即可。

针对定制化配置，Spring Boot提供了如基于入口类、配置文件、环境变量、命令行参数等多种形式。</pre>

### 基础配置
- NOTE
<pre>基础配置与在application.properties文件中的配置一样，用来修改SpringBoot预置的参数。
比如，我们想在启动程序的时候不打印Banner信息，可以通过在application.properties文件中
设置“spring.main.banner-mode=off”来进行关闭。当然，我们也可以通过SpringApplication提供
的相关方法来进行同样的操作。
springApplication.setBannerMode(Banner.Mode.OFF);

除了前面讲到的setInitializers和setListeners方法之外，其他的Setter方法都具有类似的功能，
比如我们可以通过setWebApplicationType方法来代替Spring Boot默认的自动类型推断。
针对这些Setter方法，Spring Boot还专门提供了流式处理类SpringApplicationBuilder，
我们将它的功能与SpringApplication逐一对照，可知SpringApplicationBuilder的优点
是使代码更加简洁、流畅。其他相同配置形式的功能就不再赘述了，我们可通过查看源代码进行进
一步的学习。出于集中配置、方便管理的思路，不建议大家在启动类中配置过多的参数。
比如，针对Banner的设置，我们可以在多处进行配置，但为了方便管理，
尽可能的统一在application.properties文件中。</pre>

### 配置源配置
- NOTE
<pre>除了直接通过Setter方法进行参数的配置，我们还可以通过设置配置源参数对整个配置文件或配置类
进行配置。我们可通过两个途径进行配置：SpringApplication构造方法参数或SpringApplication
提供的setSources方法来进行设置。

SpringApplication构造方法参数中可以通过Class&lt;?&gt;...primarySources参数来配置普通类。
因此，配置类可通过SpringApplication的构造方法来进行指定。
但这种方法有一个弊端就是无法指定XML配置和基于package的配置。

另外一种配置形式为直接调用setSources方法来进行设置，该方法的参数为String集合，
可传递类名、package名称和XML配置资源。

无论是通过构造参数的形式还是通过Setter方法的形式对配置源信息进行指定，在Spring Boot中都会
将其合并。SpringApplication类中提供了一个getAllSources方法，能够将两者参数进行合并。</pre>
