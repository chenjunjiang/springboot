Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot打包部署
- NOTE
<pre>Spring Boot项目支持两种常见的打包形式：jar包和war包。默认情况下创建的Spring Boot项目是
采用jar包形式，如果项目需要war包，可通过修改配置打成war包。
本章我们将围绕jar包和war包的运作原理及相关操作进行讲解。

plugin使用文档
https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/

plugin源码：
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-tools/spring-boot-maven-plugin</pre>

## Spring Boot的jar包

### jar包的生成
- NOTE
<pre>Spring Boot的可执行jar包又称作“fat jar”，是包含所有三方依赖的jar。它与传统jar包最大的不同是
包含了一个lib目录和内嵌了web容器（以下均以tomcat为例）。jar包通常是由集成在pom.xml文件
中的maven插件来生成的。配置在pom文件build元素中的plugins内。
&lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
 &lt;/plugin&gt;
 spring-boot-maven-plugin项目存在于spring-boot-tools目录中。
 spring-boot-maven-plugin默认有5个goals：repackage、run、start、stop、build-info。
 在打包的时候默认使用的是repackage。
 spring-boot-maven-plugin的repackage能够将mvn package生成的软件包，再次打包为可执行
 的软件包，并将mvn package生成的软件包重命名为*.original。
 这就为什么当执行maven clean package时，spring-boot-maven-plugin会在target目录下生成两个jar文件。
 spring-boot-1.0-SNAPSHOT.jar和spring-boot-1.0-SNAPSHOT.jar.original。
 其中我们可以将spring-learn-0.0.1-SNAPSHOT.jar.original文件的后缀.original去掉，生成的新jar
 包便是包含业务代码的包（普通的jar包）。另外的spring-learn-0.0.1-SNAPSHOT.jar包则是在
 Spring Boot中通过jar -jar启动的包，它包含了应用的依赖，以及spring boot相关class。
 spring-boot-maven-plugin的repackage在代码层面调用了RepackageMojo的execute方法。
 RepackageMojo类就是提供重新打包现有的jar或war包文件，使得它们可以使用java -jar来进行启动。
 
 RepackageMojo的execute方法如下：
 @Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.project.getPackaging().equals(&quot;pom&quot;)) {
			getLog().debug(&quot;repackage goal could not be applied to pom project.&quot;);
			return;
		}
		if (this.skip) {
			getLog().debug(&quot;skipping repackaging as per configuration.&quot;);
			return;
		}
		repackage();
	}
在execute方法中判断了是否为pom项目和是否跳过，如果是，则打印debug日志并返回；否则继续
执行repackage方法。RepackageMojo中的repackage方法相关源代码及操作解析如下。
private void repackage() throws MojoExecutionException {
        // maven生成的jar，最终的命名将会加上.original后缀
		Artifact source = getSourceArtifact();
		// 最终可执行的jar
		File target = getTargetFile();
	    // 将maven生成的jar重新打包成可执行jar
		Repackager repackager = getRepackager(source.getFile());
		// 查找并过滤项目运行时依赖的jar
		Set&lt;Artifact&gt; artifacts = filterDependencies(this.project.getArtifacts(), getFilters(getAdditionalFilters()));
		// 将artifacts转换成libraries
		Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack, getLog());
		try {
		    // 获取springboot启动脚本
			LaunchScript launchScript = getLaunchScript();
			repackager.repackage(target, libraries, launchScript);
		}
		catch (IOException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
		// 将maven生成的jar更新为.original文件
		updateArtifact(source, target, repackager.getBackupFile());
	}
	
	关于整个repackage方法的操作流程在上面代码中已经进行相应注释说明，其基本过程为：
	获得maven生成的普通jar包、获得目标File对象、获得重新打包器、获得依赖jar包、
	获得启动脚本，最后通过重新打包器进行重新打包为可通过java -jar执行的jar包。

重点看获取Repackager的方法getRepackager的源代码：
private Repackager getRepackager(File source) {
		Repackager repackager = new Repackager(source, this.layoutFactory);
		repackager.addMainClassTimeoutWarningListener(new LoggingMainClassTimeoutWarningListener());
		// 设置main class的名称，如果不指定，则会查找第一个包含main方法的类；repackage最后会将设置Main-Class: org.springframework.boot.loader.JarLauncher
		repackager.setMainClass(this.mainClass);
		if (this.layout != null) {
			getLog().info(&quot;Layout: &quot; + this.layout);
			repackager.setLayout(this.layout.layout());
		}
		return repackager;
	}
getRepackager方法主要是根据将要被转换的文件（jar或war）创建了Repackager对象，并设置启动用
的MainClass为org.springframework.boot.loader.JarLauncher，该配置对应于jar包中Manifest.MF
文件内的MainClass值。
同时，如果layout不为null，通过内部枚举类LayoutType提供的layout方法获取对应的重新打包的
实现类，比如针对jar包的org.springframework.boot.loader.tools.Layouts.Jar类。
/**
	 * Archive layout types.
	 */
	public enum LayoutType {

		/**
		 * Jar Layout.
		 */
		JAR(new Jar()),

		/**
		 * War Layout.
		 */
		WAR(new War()),

		/**
		 * Zip Layout.
		 */
		ZIP(new Expanded()),

		/**
		 * Dir Layout.
		 */
		DIR(new Expanded()),

		/**
		 * No Layout.
		 */
		NONE(new None());

		private final Layout layout;

		LayoutType(Layout layout) {
			this.layout = layout;
		}

		public Layout layout() {
			return this.layout;
		}

	}
从LayoutType的定义可以看出，Spring Boot其实是支持多种类型的archive（即归档文件）：
jar类型、war类型、zip类型、文件目录类型和NONE。很显然，使用了相同的实现类来处理ZIP
文件和DIR文件。
jar类型为Layouts类的内部类，可以简单看一下jar类型的处理类都包含了哪些内容。
public static class Jar implements RepackagingLayout {

		@Override
		public String getLauncherClassName() {
			return &quot;org.springframework.boot.loader.JarLauncher&quot;;
		}

		@Override
		public String getLibraryDestination(String libraryName, LibraryScope scope) {
			return &quot;BOOT-INF/lib/&quot;;
		}

		@Override
		public String getClassesLocation() {
			return &quot;&quot;;
		}

		@Override
		public String getRepackagedClassesLocation() {
			return &quot;BOOT-INF/classes/&quot;;
		}

		@Override
		public boolean isExecutable() {
			return true;
		}

	}
通过源代码可以看出，jar类型的归档文件（jar包）中包含了jar包启动的Main-class（JarLauncher）
、BOOT-INF/lib/目录和BOOT-INF/classes/目录。如果看Expanded和None类，会发现它们又
继承自jar。</pre>

### jar包的结构
- NOTE
<pre>通过spring-boot-maven-plugin生成了可执行的jar包，下面分析一下jar包
sspring-boot-1.0-SNAPSHOT.jar的目录结构。
在上述结构中，BOOT-INF/classes目录中存放业务代码，BOOT-INF/lib目录中存放了除java虚拟机
之外的所有依赖；org目录中存放了Spring Boot用来启动jar包的相关class文件；
META-INF目录中存放了MANIFEST.MF、maven信息和spring.factories文件。

其中，Manifest.MF文件通常被用来定义扩展或档案打包相关数据，它是一个元数据文件，数据格式为
名/值对。一个可执行的jar文件需要通过该文件来指出该程序的主类。
Manifest-Version: 1.0
Implementation-Title: spring-boot
Implementation-Version: 1.0-SNAPSHOT
Start-Class: com.chenjj.spring.boot.Application
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Build-Jdk-Spec: 1.8
Spring-Boot-Version: 2.2.1.RELEASE
Created-By: Maven Archiver 3.4.0
Main-Class: org.springframework.boot.loader.JarLauncher

Manifest.MF文件中定义Main-Class设置为org.springframework.boot.loader.JarLauncher，
也就是说，jar包程序启动入口为JarLauncher类的main方法。JarLauncher类位于
spring-boot-loader项目中，在jar包的org目录中便存储着Launcher相关类的class文件。
项目的引导类定义在Start-Class属性中，需要注意的是，Start-Class属性并非Java标准的
Manifest.MF属性。</pre>

## Launcher实现原理及war包
> leftSide=`true`


### 实现原理
- NOTE
<pre>我们得知jar包Main-Class指定入口程序为Spring Boot提供的Launcher（JarLauncher），并不是
我们在Spring Boot项目中所写的入口类。那么，Launcher类又是如何实现项目的启动呢？
Launcher类的具体实现类有3个：JarLauncher、WarLauncher和PropertiesLauncher，我们这里
主要讲解JarLauncher和WarLauncher。首先，以JarLauncher为例来解析说明Spring Boot基于
Launcher来实现的启动过程。
public class JarLauncher extends ExecutableArchiveLauncher {

	static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

	static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

	public JarLauncher() {
	}

	protected JarLauncher(Archive archive) {
		super(archive);
	}

	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(BOOT_INF_CLASSES);
		}
		return entry.getName().startsWith(BOOT_INF_LIB);
	}

	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}

}
JarLauncher类结构非常简单，它继承了抽象类ExecutableArchiveLauncher，而抽象类又继承了
抽象类Launcher。JarLauncher中定义了两个常量：BOOT_INF_CLASSES和BOOT_INF_LIB，
它们分别定义了业务代码存放在jar包中的位置（BOOT-INF/classes/）和依赖jar包所在的位置
（BOOT-INF/lib/）。
JarLauncher中提供了一个main方法，即入口程序的功能，在该方法中首先
创建了JarLauncher对象，然后调用其launch方法。大家都知道，当创建子类对象时，会先调用父类
的构造方法。因此，父类ExecutableArchiveLauncher的构造方法被调用。
public abstract class ExecutableArchiveLauncher extends Launcher {

	private final Archive archive;

	public ExecutableArchiveLauncher() {
		try {
			this.archive = createArchive();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	......
	}
在ExecutableArchiveLauncher的构造方法中仅实现了父类Launcher的createArchive方法的调用和
异常的抛出。Launcher类中createArchive方法源代码如下。
protected final Archive createArchive() throws Exception {
		ProtectionDomain protectionDomain = getClass().getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
		String path = (location != null) ? location.getSchemeSpecificPart() : null;
		if (path == null) {
			throw new IllegalStateException(&quot;Unable to determine code source archive&quot;);
		}
		File root = new File(path);
		if (!root.exists()) {
			throw new IllegalStateException(&quot;Unable to determine code source archive from &quot; + root);
		}
		return (root.isDirectory() ? new ExplodedArchive(root) : new JarFileArchive(root));
	}
在createArchive方法中，根据当前类信息获得当前归档文件的路径
（即打包后生成的可执行的spring-learn-0.0.1-SNAPSHOT.jar），并检查文件路径是否存在。
如果存在且是文件夹，则创建ExplodedArchive的对象，否则创建JarFileArchive的对象。
关于Archive，它在Spring Boot中是一个抽象的概念，Archive可以是一个jar（JarFileArchive），
也可以是一个文件目录（ExplodedArchive），上面的代码已经进行了很好地证明。
你可以理解为它是一个抽象出来的统一访问资源的层。Archive接口的具体定义如下。
public interface Archive extends Iterable&lt;Archive.Entry&gt;, AutoCloseable {

	/**
	 * 获取该归档的url
	 * @return the archive URL
	 * @throws MalformedURLException if the URL is malformed
	 */
	URL getUrl() throws MalformedURLException;

	/**
	 * 获取jar!/META-INF/MANIFEST.MF或[ArchiveDir]/META-INF/MANIFEST.MF
	 * @return the manifest
	 * @throws IOException if the manifest cannot be read
	 */
	Manifest getManifest() throws IOException;
	
	/**
	 * 获取jar!/BOOT-INF/lib/*.jar或[ArchiveDir]/BOOT-INF/lib/*.jar
	 * @param filter the filter used to limit entries
	 * @return nested archives
	 * @throws IOException if nested archives cannot be read
	 */
	List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException;
	......
	}
通过Archive接口中定义的方法可以看出，Archive不仅提供了获得归档自身URL的方法，也提供了
获得该归档内部jar文件列表的方法，而jar内部的jar文件依旧会被Spring Boot认为是一个Archive。
通常，jar里的资源分隔符是!/，在JDK提供的JarFile URL只支持一层“!/”，而Spring Boot扩展了该协议，
可支持多层“!/”。因此，在Spring Boot中也就可以表示jar in jar、jar in directory、fat jar类型的资源了。

我们再回到JarLauncher的入口程序，当创建JarLauncher对象，获得了当前归档文件的Archive，
下一步便是调用launch方法，该方法由Launcher类实现。Launcher中的这个launch方法就是启动
应用程序的入口，而该方法的定义是为了让子类的静态main方法调用的。
protected void launch(String[] args) throws Exception {
        // 注册一个&quot;java.protocol.handlers&quot;属性，以便定位URLStreamHandler来处理jar URL
		JarFile.registerUrlProtocolHandler();
		// 获取Archive，并通过Archive的URL获得ClassLoader（LaunchURLClassLoader）
		ClassLoader classLoader = createClassLoader(getClassPathArchives());
		// 启动应用程序(创建MainMethodRunner类并调用其run方法)
		launch(args, getMainClass(), classLoader);
	}

下面看在launch方法中都具体做了什么操作，首先调用了JarFile的registerUrlProtocolHandler方法。
JarFile的registerUrlProtocolHandler方法利用了java.net.URLStreamHandler扩展机制，其实现由
URL#getURLStreamHandler(String)提供，该方法返回一个URLStreamHandler类的实现类。
针对不同的协议，通过实现URLStreamHandler来进行扩展。JDK默认支持了文件（file）、
HTTP、JAR等协议。
关于实现URLStreamHandler类来扩展协议，JVM有固定的要求。
第一：子类的类名必须是Handler，最后一级包名必须是协议的名称。比如，自定义了Http的协议
实现，则类名必然为xx.http.Handler，而JDK对http实现为：sun.net.protocol.http.Handler。
第二：JVM启动时，通常需要配置Java系统属性java.protocol.handler.pkgs，追加
URLStreamHandler实现类的package。如果有多个实现类（package），则用“|”隔开。

JarFile#registerUrlProtocolHandler(String)方法就是将org.springframework.boot.loader追加
到Java系统属性java.protocol.handler.pkgs中。
执行完JarFile.registerUrlProtocolHandler()之后，执行createClassLoader方法创建ClassLoader。
该方法的参数是通过ExecutableArchiveLauncher实现getClassPathArchives方法获得的。
protected List&lt;Archive&gt; getClassPathArchives() throws Exception {
		List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(this.archive.getNestedArchives(this::isNestedArchive));
		postProcessClassPathArchives(archives);
		return archives;
	}
在getClassPathArchives方法中通过调用当前archive的getNestedArchives方法，
找到/BOOT-INF/lib下jar及/BOOT-INF/classes目录所对应的archive，通过这些archive的URL生成
LaunchedURLClassLoader。创建LaunchedURLClassLoader是由Launcher中重载的
createClassLoader方法实现的，代码如下。
protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception {
		List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size());
		for (Archive archive : archives) {
			urls.add(archive.getUrl());
		}
		return createClassLoader(urls.toArray(new URL[0]));
	}

protected ClassLoader createClassLoader(URL[] urls) throws Exception {
		return new LaunchedURLClassLoader(urls, getClass().getClassLoader());
	}

Launcher#launch方法的最后一步，是将ClassLoader（LaunchedURLClassLoader）设置为线程
上下文类加载器，并创建MainMethodRunner对象，调用其run方法。
launch(args, getMainClass(), classLoader);

protected String getMainClass() throws Exception {
		Manifest manifest = this.archive.getManifest();
		String mainClass = null;
		if (manifest != null) {
			mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);
		}
		if (mainClass == null) {
			throw new IllegalStateException(&quot;No 'Start-Class' manifest entry specified in &quot; + this);
		}
		return mainClass;
	}
	
protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception {
		Thread.currentThread().setContextClassLoader(classLoader);
		createMainMethodRunner(mainClass, args, classLoader).run();
	}

public void run() throws Exception {
		Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader().loadClass(this.mainClassName);
		Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);
		mainMethod.invoke(null, new Object[] { this.args });
	}
上述代码中属性mainClass参数便是在Manifest.MF文件中我们自定义的Spring Boot的入口类，
即Start-class属性值。在MainMethodRunner的run方法中，通过反射获得入口类的main方法并调用。
至此，Spring Boot入口类的main方法正式执行，所有应用程序类文件均可通过/BOOT-INF/classe
加载，所有依赖的第三方jar均可通过/BOOT-INF/lib加载。</pre>

### war包
- NOTE
<pre>WarLauncher与JarLauncher都继承自抽象类ExecutableArchiveLauncher，它们的实现方式和流程
基本相同，差异很小。主要的区别是war包中的目录文件和jar包路径不同。WarLauncher部分源代码如下。

public class WarLauncher extends ExecutableArchiveLauncher {

	private static final String WEB_INF = &quot;WEB-INF/&quot;;

	private static final String WEB_INF_CLASSES = WEB_INF + &quot;classes/&quot;;

	private static final String WEB_INF_LIB = WEB_INF + &quot;lib/&quot;;

	private static final String WEB_INF_LIB_PROVIDED = WEB_INF + &quot;lib-provided/&quot;;

	public WarLauncher() {
	}

	protected WarLauncher(Archive archive) {
		super(archive);
	}

	@Override
	public boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(WEB_INF_CLASSES);
		}
		else {
			return entry.getName().startsWith(WEB_INF_LIB) || entry.getName().startsWith(WEB_INF_LIB_PROVIDED);
		}
	}

	public static void main(String[] args) throws Exception {
		new WarLauncher().launch(args);
	}

}
JarLauncher在构建LauncherURLClassLoader时搜索BOOT-INF/classes目录及BOOT-INF/lib目录
下的jar。而通过上述代码可以看出，WarLauncher在构建LauncherURLClassLoader时搜索的是
WEB-INF/classes目录及WEB-INF/lib和WEB-INF/lib-provided目录下的jar。

下面，我们通过对jar打包形式的Spring Boot项目进行修改，变成可打包成war的项目。然后，
再看一下打包成的war的目录结构。
第一步，修改pom.xml中的packaging为war。
&lt;packaging&gt;war&lt;/packaging&gt;

第二步，在spring-boot-starter-web依赖中排除tomcat，并新增servlet-api依赖，
这里采用的是Servlet 3.1.0版本。

第三步，在build配置中将插件替换为maven-war-plugin。
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
    &lt;configuration&gt;
          &lt;failOnMissingWebXml&gt;false&lt;failOnMissingWebXml/&gt;
    &lt;/configuration&gt;
&lt;/dependency&gt;

第四步，让Spring Boot入口类继承SpringBootServletInitializer并实现其方法。
@SpringBootApplication
public class Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(Application.class);
    }

    public static void main(String[] args) {
        try {
            ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
            ArgsBean argsBean = context.getBean(ArgsBean.class);
            argsBean.printArgs();
            System.out.println(&quot;Application started&quot;);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
执行，maven clean package即可得到对应的war包。同样，这里会生成两个war包文件：
一个后缀为.war的可独立部署的文件，一个war.original文件，具体命名形式参考jar包。

最后，war包文件既能被WarLauncher启动，又能兼容Servlet容器。其实，jar包和war并无本质区别，
因此，如果无特殊情况，尽量采用jar包的形式来进行打包部署。
</pre>
