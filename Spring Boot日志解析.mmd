Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot日志解析
- NOTE
<pre>Spring Boot使用Commons Logging进行所有内部日志的记录。SpringBoot同时提供了
Java Util Logging、Log4J2和Logback的默认配置，都可以通过预置的配置来设置控制台和文件格式
的日志输出。</pre>

## LoggingApplicationListener的触发
- NOTE
<pre>讲到日志的触发过程，我们首先看一下日志监听器LoggingApplicationListener的注册方法，
在之前我们已经讲到，在Spring Boot启动的过程中会获得spring-boot.jar包中的META-INF/spring.factories配置文件中的
Application注册监听器，其中就包含日志的监听器LoggingApplicationListener
org.springframework.boot.context.logging.LoggingApplicationListener

当在此注册之后，在SpringApplication的构造方法中会获得实现ApplicationListener接口的注册
监听器，这个监听器会被设置到SpringApplication的listeners属性当中。
在启动过程中，SpringApplication的run方法会获得spring-boot项目中在
META-INF/spring.factories配置文件中的Run Listeners，配置如下。
# Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener
SpringApplication的run方法中会获取SpringApplicationRunListener接口的监听注册类：
SpringApplicationRunListeners listeners = getRunListeners(args);

在getRunListeners方法中，通过getSpringFactoriesInstances方法，获得spring.factories中注册
的SpringApplicationRunListener接口的实现类集合，默认情况下集合中只有一个
EventPublishingRunListener类。
然后，将包含EventPublishingRunListener的集合封装到SpringApplicationRunListeners中，
在Spring Boot启动过程的不同阶段会触发不同的事件，比如listeners.starting()等方法。
关于SpringApplicationRunListeners的功能我们已经学习过，当触发事件的方法被调用时，会遍历
监听器并调用对应的方法。比如，调用listeners.starting()方法，会通过其内部的遍历方法，
最终调用到EventPublishingRunListener的starting方法。
EventPublishingRunListener类是SpringApplicationRunListener的实现类，因此当遍历调用
SpringApplicationRunListener的starting方法时，最终调用了EventPublishingRunListener实现
的starting方法：
@Override
	public void starting() {
		this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
	}
EventPublishingRunListener的starting方法会通过SimpleApplicationEventMulticaster广播一个
ApplicationStartingEvent事件。该事件会触发在构造方法中注册的LoggingApplicationListener
监听器，进行日志相关的逻辑处理。
</pre>

## LoggingApplicationListener的执行
> leftSide=`true`

- NOTE
<pre>LoggingApplicationListener实现自GenericApplicationListener接口，具有监听器的特性。
因此，执行EventPublishingRunListener广播事件之后，LoggingApplicationListener便会监听到
对应的事件并执行onApplicationEvent方法中的逻辑判断，有针对性地处理不同的事件，相关代码如下。
@Override
	public void onApplicationEvent(ApplicationEvent event) {
	   // 应用上下文准备完成，但未刷新时触发
		if (event instanceof ApplicationStartingEvent) {
			onApplicationStartingEvent((ApplicationStartingEvent) event);
		}
		else if (event instanceof ApplicationEnvironmentPreparedEvent) {
			onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
		}
		else if (event instanceof ApplicationPreparedEvent) {
			onApplicationPreparedEvent((ApplicationPreparedEvent) event);
		}
		else if (event instanceof ContextClosedEvent
				&amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == null) {
			// 容器关闭时处理
			onContextClosedEvent();
		}
		else if (event instanceof ApplicationFailedEvent) {
		   // 启动失败时处理
			onApplicationFailedEvent();
		}
	}
以上代码中的事件处理基本涵盖了Spring Boot启动的不同阶段和不同状况，比如Spring Boot刚刚
启动阶段、环境准备初级阶段、应用上下文准备完成阶段、容器关闭阶段、应用程序启动失败等。

1、ApplicationStartingEvent事件处理
在Spring Boot的启动过程中，通过SpringApplicationRunListeners类间接的调用了
EventPublishingRunListener中的各类事件的发布方法，最终被LoggingApplicationListener监听并进行处理。

Spring Boot刚刚启动时发布了ApplicationStartingEvent事件，LoggingApplicationListener中的
onApplicationStartingEvent方法便被调用了，该方法源码如下。
private void onApplicationStartingEvent(ApplicationStartingEvent event) {
		this.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());
		this.loggingSystem.beforeInitialize();
	}
在onApplicationStartingEvent方法中，首先获得一个LoggingSystem对象，然后调用对象的
beforeInitialize方法进行预初始化操作。也就是说在Spring Boot开始启动时，日志系统做了两件事：
创建LoggingSystem对象和预初始化操作。
public static LoggingSystem get(ClassLoader classLoader) {
		String loggingSystem = System.getProperty(SYSTEM_PROPERTY);
		if (StringUtils.hasLength(loggingSystem)) {
			if (NONE.equals(loggingSystem)) {
				return new NoOpLoggingSystem();
			}
			return get(classLoader, loggingSystem);
		}
		return SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))
				.map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()
				.orElseThrow(() -&gt; new IllegalStateException(&quot;No suitable logging system located&quot;));
	}
该方法首先判断系统中是否配置了LoggingSystem的配置，存在且不为“none”时，则利用反射机制
进行初始化；如果明确配置为“none”，则返回NoOpLoggingSystem对象。

如果系统中不存在该对象的配置，则从SYSTEMS筛选获取第一个符合条件的值，然后进行初始化。
SYSTEMS为LoggingSystem的静态变量，通过静态代码块进行初始化，相关代码如下。
private static final Map&lt;String, String&gt; SYSTEMS;

	static {
		Map&lt;String, String&gt; systems = new LinkedHashMap&lt;&gt;();
		systems.put(&quot;ch.qos.logback.core.Appender&quot;, &quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;);
		systems.put(&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;,
				&quot;org.springframework.boot.logging.log4j2.Log4J2LoggingSystem&quot;);
		systems.put(&quot;java.util.logging.LogManager&quot;, &quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;);
		SYSTEMS = Collections.unmodifiableMap(systems);
	}
常量SYSTEMS是Map结构，其中key为对应日志系统的核心类（类似@ConditionalOnClass注解中
指定的类），value的值是LoggingSystem的具体实现类。在静态代码块中，初始化分别添加了
LogbackLoggingSystem、Log4J2LoggingSystem和JavaLoggingSystem，
这也是Spring Boot默认内置的3个日志实现类。而且SYSTEMS被初始化之后便不可被修改了。
其中从SYSTEMS中筛选出符合条件的LoggingSystem实现类，这里采用了Java 8新增的Stream语法
来实现，基本处理过程是这样的：遍历SYSTEMS中的值，通过ClassUtils的isPresent方法过滤符合
条件的值（key对应的类存在于classpath中）；然后通过上面提到的反射方法创建筛选过后的值的对象；
最后获取第一个对象并返回。如果未获取到则抛出异常。

由于SYSTEMS是基于LinkedHashMap实现的，因此，这里可以看出默认情况下Spring Boot优先
采用org.springframework.boot.logging.logback.LogbackLoggingSystem实现类。
也就是说，默认情况下使用Logback进行日志配置。但是这里有个前提，classpath下必须存在
logback相关的类，如果不存在就会找下一个日志进行配置， 比如：我的项目里面引入了log4j2，
那么就会采用Log4J2LoggingSystem。
完成LoggingSystem初始化之后，程序便调用其beforeInitialize方法进行初始化前的准备工作。
在LoggingSystem中beforeInitialize为抽象方法，由子类实现。该方法在Log4J2LoggingSystem
中的源码实现如下。
Override
	public void beforeInitialize() {
		LoggerContext loggerContext = getLoggerContext();
		if (isAlreadyInitialized(loggerContext)) {
			return;
		}
		super.beforeInitialize();
		loggerContext.getConfiguration().addFilter(FILTER);
	}
该方法的主要功能是获得LoggerContext并校验是否存在对应的logger，如果不存在则调用父类的
初始化方法，并拒绝在LoggerContext没有初始化之前对应打印的日志的全部请求。
Log4J2LoggingSystem的父类为Slf4JLoggingSystem，因此方法中调用了
Slf4JLoggingSystem的beforeInitialize方法，相关源码如下。
@Override
	public void beforeInitialize() {
		super.beforeInitialize();
		configureJdkLoggingBridgeHandler();
	}

private void configureJdkLoggingBridgeHandler() {
		try {
			if (isBridgeJulIntoSlf4j()) {
				removeJdkLoggingBridgeHandler();
				SLF4JBridgeHandler.install();
			}
		}
		catch (Throwable ex) {
			// Ignore. No java.util.logging bridge is installed.
		}
	}

上述代码涵盖了Slf4JLoggingSystem中大多数的功能，其主要目的就是处理内置日志（JUL）与
SLF4J的Handler的桥接转换操作。
基本判断逻辑如下：如果类路径下存在SLF4JBridgeHandler类，并且根Logger中不包含或仅包含
ConsoleHandler时，说明需要将内置日志转换为SLF4J。基本转换过程分两步：删除原有Handler、
新增指定的Handler；如果满足条件，先删除内置日志的Handler，然后再删除SLF4J的Handler，
最后再将SLF4J对应的SLF4JBridgeHandler添加到根Logger中。


2、ApplicationEnvironmentPreparedEvent事件处理
当Spring Boot继续启动操作，便会广播ApplicationEnvironmentPreparedEvent事件，
此时便会调用LoggingApplicationListener的onApplicationEnvironmentPreparedEvent方法，
该方法源码如下。
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
		if (this.loggingSystem == null) {
			this.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());
		}
		initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());
	}
完成loggingSystem的再次判断并创建之后，调用initialize方法进行初始化操作，主要完成了初始参数
的设置、日志文件、日志级别设置以及注册ShutdownHook等操作，相关代码如下。
protected void initialize(ConfigurableEnvironment environment, ClassLoader classLoader) {
		new LoggingSystemProperties(environment).apply();
		this.logFile = LogFile.get(environment);
		if (this.logFile != null) {
			this.logFile.applyToSystemProperties();
		}
		this.loggerGroups = new LoggerGroups(DEFAULT_GROUP_LOGGERS);
		initializeEarlyLoggingLevel(environment);
		initializeSystem(environment, this.loggingSystem, this.logFile);
		initializeFinalLoggingLevels(environment, this.loggingSystem);
		registerShutdownHookIfNecessary(environment, this.loggingSystem);
	}
上述代码中，创建LoggingSystemProperties对象之后主要是通过调用其apply方法来获取默认的
日志配置参数（在配置文件中以“logging.”开头的属性），并设置到系统属性中。
LogFile的get方法主要是获取日志文件的路径和名称，并作为参数创建Logfile对象。LogFile中get
方法相关代码如下。
public static LogFile get(PropertyResolver propertyResolver) {
		String file = getLogFileProperty(propertyResolver, FILE_NAME_PROPERTY, FILE_PROPERTY);
		String path = getLogFileProperty(propertyResolver, FILE_PATH_PROPERTY, PATH_PROPERTY);
		if (StringUtils.hasLength(file) || StringUtils.hasLength(path)) {
			return new LogFile(file, path);
		}
		return null;
	}
从上述代码可以看出，通过获取属性名为“logging.file.path”的值得到了日志的路径，通过获取属性名
为“logging.file.name”的值得到了日志文件名。其中getLogFileProperty的第3个参数为兼容历史
版本中的配置属性名。当然，程序会优先获取当前版本的属性配置，当查找不到值时才会获取历史
版本的值。
紧接着，initialize方法中判断当LogFile不为null时，调用它的applyToSystemProperties方法，
也就是将上述获得的日志文件路径和名称存入系统属性当中。
initializeEarlyLoggingLevel方法用于早期设置springBootLogging的值和LoggingSystem的初始化，
代码如下。
private void initializeEarlyLoggingLevel(ConfigurableEnvironment environment) {
		if (this.parseArgs &amp;&amp; this.springBootLogging == null) {
			if (isSet(environment, &quot;debug&quot;)) {
				this.springBootLogging = LogLevel.DEBUG;
			}
			if (isSet(environment, &quot;trace&quot;)) {
				this.springBootLogging = LogLevel.TRACE;
			}
		}
	}
上述代码主要根据parseArgs参数（默认为true）和springBootLogging是否为null，
在早期阶段中设置springBootLogging的值，也就是日志级别。在parseArgs为true，
并且springBootLogging值为null的情况下，如果ConfigurableEnvironment中debug的值存在
且为true，则设置springBootLogging为DEBUG。同样，如果trace的值存在且为true，则设置
springBootLogging为TRACE。
</pre>
