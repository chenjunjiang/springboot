Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot运行流程分析

## run方法核心流程
- NOTE
<pre>SpringApplication在run方法中重点做了以下操作：
·获取监听器和参数配置。
·打印Banner信息。
·创建并初始化容器。
·监听器发送通知。
当然，除了核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、
异常处理等辅助操作。

public ConfigurableApplicationContext run(String... args)

</pre>

## SpringApplicationRunListener监听器
> leftSide=`true`

- NOTE
<pre>监听器的配置与加载
SpringApplicationRunListeners listeners = getRunListeners(args);
SpringApplicationRunListeners可以理解为一个SpringApplicationRunListener的容器，
它将SpringApplicationRunListener的集合以构造方法传入，并赋值给其listeners成员变量，
然后提供了针对listeners成员变量的各种遍历操作方法，比如，遍历集合并调用对应的starting、
started、running等方法。

private SpringApplicationRunListeners getRunListeners(String[] args) {
		Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };
		return new SpringApplicationRunListeners(logger,
				getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));
	}
SpringApplicationRunListeners构造方法的第二个参数便是SpringApplicationRunListener的集合，
SpringApplication中调用构造方法时该参数是通过getSpringFactoriesInstances方法获取的。
通过方法名便可得知，getSpringFactoriesInstances是用来获取factories配置文件中的注册类，
并进行实例化操作。（通过SpringFactoriesLoader获取META-INF/spring.factories中对应的配置）

SpringApplicationRunListener的注册配置位于spring-boot项目中(spring-boot-2.2.1.RELEASE.jar)
的spring.factories文件内，Spring Boot默认仅有一个监听器进行了注册：
# Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener

我们继续看实例化监听器的方法createSpringFactoriesInstances：
private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,
			ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) {
		List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());
		for (String name : names) {
			try {
				Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);
				Assert.isAssignable(type, instanceClass);
				Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);
				T instance = (T) BeanUtils.instantiateClass(constructor, args);
				instances.add(instance);
			}
			catch (Throwable ex) {
				throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);
			}
		}
		return instances;
	}
在上面的代码中，实例化监听器时需要有一个默认的构造方法，且构造方法的参数为
Class&lt;?&gt;[ ] parameterTypes。我们向上追踪该参数的来源，会发现该参数的值为Class数组，
数组的内容依次为SpringApplication.class和String[ ].class。也就是说，
SpringApplicationRunListener的实现类必须有默认的构造方法，且构造方法的参数必须依次为
SpringApplication和String[]类型。比如EventPublishingRunListener，它的构造方法是：
public EventPublishingRunListener(SpringApplication application, String[] args)

SpringApplicationRunListener源码解析
接口SpringApplicationRunListener是SpringApplication的run方法监听器。上节提到了
SpringApplicationRunListener通过SpringFactoriesLoader加载，并且必须声明一个公共构造函数，
该函数接收SpringApplication实例和String[ ]的参数，而且每次运行都会创建一个新的实例。
SpringApplicationRunListener提供了一系列的方法，用户可以通过回调这些方法，
在启动各个流程时加入指定的逻辑处理。
public interface SpringApplicationRunListener {
     /**
	   * 当run()方法第一次被执行时，会被立即调用，可以用于非常早期的初始化工作
	 */
	default void starting() {
	}

	/**
	 *  当environment准备完成，在ApplicationContext创建之前，该方法被调用
	 */
	default void environmentPrepared(ConfigurableEnvironment environment) {
	}

	/**
	 * 当ApplicationContext构建完成，资源还未被加载时，该方法被调用
	 */
	default void contextPrepared(ConfigurableApplicationContext context) {
	}

	/**
	 * 当ApplicationContext加载完成，未被刷新之前，该方法被调用
	 */
	default void contextLoaded(ConfigurableApplicationContext context) {
	}

	/**
	 * 当ApplicationContext刷新并启动之后，CommandLineRunner和ApplicationRunner未被调用之前，该方法被调用
	 */
	default void started(ConfigurableApplicationContext context) {
	}

	/**
	 * 所有工作准备就绪，run()方法执行完成前，该方法被调用，此时CommandLineRunner和ApplicationRunner
	 已经被调用
	 */
	default void running(ConfigurableApplicationContext context) {
	}

	/**
	* 当应用程序执行出错时，该方法会被调用
	 */
	default void failed(ConfigurableApplicationContext context, Throwable exception) {
	}
}
我们通过源代码可以看出，SpringApplicationRunListener为run方法提供了各个运行阶段的监听
事件处理功能。需要注意的是，该版本中的接口方法定义使用了Java8的新特性，方法已采用
default声明并实现空方法体，表示这个方法的默认实现，子类可以直接调用该方法，也可以选择
重写或者不重写。

实现类EventPublishingRunListener
EventPublishingRunListener是Spring Boot中针对SpringApplicationRunListener接口的唯一内
建实现。EventPublishingRunListener使用内置的SimpleApplicationEventMulticaster来广播
在上下文刷新之前触发的事件。
默认情况下，Spring Boot在初始化过程中触发的事件也是交由EventPublishingRunListener来代理
实现的。
EventPublishingRunListener的构造方法如下：
public EventPublishingRunListener(SpringApplication application, String[] args) {
		this.application = application;
		this.args = args;
		this.initialMulticaster = new SimpleApplicationEventMulticaster();
		for (ApplicationListener&lt;?&gt; listener : application.getListeners()) {
			this.initialMulticaster.addApplicationListener(listener);
		}
	}
可以看出，该类的构造方法符合SpringApplicationRunListener所需的构造方法参数要求，该方法
依次传递了SpringApplication和String[ ]类型。在构造方法中初始化了该类的3个成员变量。
·application：类型为SpringApplication，是当前运行的SpringApplication实例。
·args：启动程序时的命令参数。
·initialMulticaster：类型为SimpleApplicatiSpring Boot完成基本的初始化之后，会遍历
SpringApplication的所有ApplicationListener实例，并将它们与
SimpleApplicationEventMulticaster进行关联，方便SimpleApplicationEvent-Multicaster后续将
事件传递给所有的监听器。onEventMulticaster，事件广播器。

梳理一下整个事件的流程：
·程序启动到某个步骤后，调用EventPublishingRunListener的某个方法。
·EventPublishingRunListener的具体方法将application参数和args参数封装到对应的事件中。
这里的事件均为SpringApplicationEvent的实现类。
·通过成员变量initialMulticaster的multicastEvent方法对事件进行广播，或通过该方法的
ConfigurableApplicationContext参数的publishEvent方法来对事件进行发布。
·对应的ApplicationListener被触发，执行相应的业务逻辑。
源代码中你是否发现一个问题，某些方法是通过initialMulticaster的multicastEvent进行事件的广播，
某些方法是通过context参数的publishEvent方法来进行发布的。这是为什么呢？
contextLoaded方法之前执行的事件广播都是通过multicastEvent来进行的，而该方法之后的
方法则均采用publishEvent来执行。这是因为只有到了contextLoaded方法之后，上下文才算
初始化完成，才可通过它的publishEvent方法来进行事件的发布。


</pre>

## 初始化ApplicationArguments
> leftSide=`true`

- NOTE
<pre>监听器启动之后，紧接着便是执行ApplicationArguments对象的初始化，ApplicationArguments是
用于提供访问运行SpringApplication时的参数。ApplicationArguments的初始化过程非常简单，
只是调用了它的实现类Default-ApplicationArguments并传入main方法中的args参数。
ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
在DefaultApplicationArguments中将参数args封装为Source对象，Source对象是基于Spring
框架的SimpleCommandLinePropertySource来实现的。

我们对该接口在此不进行拓展，只需知道通过main方法传递进来的参数被封装成
ApplicationArguments对象即可。关于该接口实例化的步骤我会在后续关于Spring Boot的参数的
章节中进行详细讲解。</pre>

## 初始化ConfigurableEnvironment
- NOTE
<pre>完成ApplicationArguments参数的准备之后，便开始通过prepareEnvironment方法对
ConfigurableEnvironment对象进行初始化操作。ConfigurableEnvironment接口继承自
Environment接口和ConfigurablePropertyResolver，最终都继承自接口PropertyResolver。
ConfigurableEnvironment接口的主要作用是提供当前运行环境的公开接口，比如配置文件
profiles各类系统属性和变量的设置、添加、读取、合并等功能。
通过ConfigurableEnvironment接口中方法定义，可以更清楚地了解它的功能：
    /**
	 * 设置激活的组集合
	 */
void setActiveProfiles(String... profiles);

	/**
	 * 向当前激活的组集合中添加一个profile组
	 */
	void addActiveProfile(String profile);

	/**
	  * 设置默认激活的组集合。激活的组集合为空时会使用默认的
	 */
	void setDefaultProfiles(String... profiles);

	/**
	  * 获取当前环境对象中的属性源集合，也就是应用环境变量。
	  * 属性源集合其实就是一个容纳PropertySource的容器，
	  * 该方法提供了直接配置属性源的入口。
	 */
	MutablePropertySources getPropertySources();

	/**
	 * 获取虚拟机环境变量
	 */
	Map&lt;String, Object&gt; getSystemProperties();

	/**
	 * 获取操作系统环境变量
	 */
	Map&lt;String, Object&gt; getSystemEnvironment();

	/**
	  * 合并指定环境中的配置到当前环境中
	 */
	void merge(ConfigurableEnvironment parent);
	
run方法中调用prepareEnvironment方法相关代码如下：
ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments){
			......
			}
prepareEnvironment进行了以下的操作：
·获取或创建环境。
·配置环境。
·ConfigurationPropertySources附加到指定环境：将ConfigurationPropertySources附加到指定
环境中的第一位，并动态跟踪环境的添加或删除。
·设置listener监听事件：此处主要针对准备环境的监听。
·绑定环境到SpringApplication：将环境绑定到name为“spring.main”的目标上。
·转换环境：判断是否是定制的环境，如果不是定制的，则将环境转换为Standard-Environment。
此时判断条件isCustomEnvironment默认为false，在后面的操作中会将其设置为true，
如果为true则不再会进行此转换操作。
·ConfigurationPropertySources附加到指定环境：将ConfigurationPropertySources附加到指定
环境中的第一位，并动态跟踪环境的添加或删除操作。

</pre>

## 忽略信息配置
> leftSide=`true`

- NOTE
<pre>ConfigurableEnvironment的初始化和准备工作完成之后，程序又对环境中的忽略信息配置项
“spring.beaninfo.ignore”的值进行获取判断，进而设置为系统参数中的忽略项。
private void configureIgnoreBeanInfo(ConfigurableEnvironment environment)
{
}
spring.beaninfo.ignore的配置用来决定是否跳过BeanInfo类的扫描，如果设置为true，则跳过。
这里的BeanInfo类就是指Java内省里面的BeanInfo？</pre>

## 打印Banner
- NOTE
<pre>完成环境的基本处理之后，下面就是控制台Banner的打印了。Spring Boot的Banner打印是一个
比较酷炫的功能，但又显得有些华而不实，特别是打印图片时启动速度会变慢。

程序通过Banner.Mode枚举值来判断是否开启Banner打印，此项参数可以在SpringBoot入口main
方法中通过setBannerMode方法来设置，也可以通过application.properties中的
spring.main.banner-mode进行设置。SpringApplicationBannerPrinter类承载了Banner初始化
及打印的核心功能，比如默认如何获取Banner信息、如何根据约定优于配置来默认获得Banner
的内容、Banner支持的文件格式等。而具体打印的信息是由Banner接口的实现类来完成的，
比如默认情况下使用SpringBootBanner来打印Spring Boot的版本信息及简单的图形。
当然还有通过资源文件打印的ResourceBanner，通过图片打印的ImageBanner等方法。</pre>

## Spring应用上下文的创建
> leftSide=`true`

- NOTE
<pre>在Spring Boot中通过SpringApplication类中的createApplicationContext来进行应用上下文的创建：
protected ConfigurableApplicationContext createApplicationContext() {
......
}
那么，在createApplicationContext方法中，什么时候applicationContextClass变量不为null呢
？比如，当我们创建SpringApplication之后，在调用run方法之前，调用其
setApplicationContextClass方法指定了ConfigurableApplicationContext的设置。
但需要注意的是，该方法不仅设置了applicationContextClass的值，同时也设置了
webApplicationType的值，需慎用。

可以看出createApplicationContext方法中核心操作就是根据枚举类型进行判断，创建不同的上下文容器。
</pre>

## Spring应用上下文的准备
- NOTE
<pre>SpringApplication继续通过prepareContext方法来进行应用上下文的准备工作。
private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
			SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)
{
  ......
}
流程见 应用上下文准备、加载阶段流程图.png

</pre>

## Spring应用上下文的刷新
> leftSide=`true`

- NOTE
<pre>Spring应用上下文的刷新，是通过调用SpringApplication中的refreshContext方法来完成的。
refreshContext(context);

其中refresh方法调用的是AbstractApplicationContext中的refresh方法，该类属于spring-context包。
AbstractApplicationContext的refresh方法更多的是Spring相关的内容，这里我们通过refresh方法
的顶层代码了解该方法都做了些什么，不过多深入Spring内部进行讲解。
public void refresh() throws BeansException, IllegalStateException {
      // 整个过程同步处理
		synchronized (this.startupShutdownMonitor) {
			// 准备刷新工作
			prepareRefresh();

			// 通知子类刷新内部bean工厂
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// 为当前context准备bean工厂
			prepareBeanFactory(beanFactory);

			try {
				// 允许context的子类对bean工厂进行后置处理
				postProcessBeanFactory(beanFactory);

				// 调用context中注册的bean的工厂处理器
				invokeBeanFactoryPostProcessors(beanFactory);

				// 注册bean处理器(beanPostProcessors)
				registerBeanPostProcessors(beanFactory);

				// 初始化context的信息源，和国际化有关
				initMessageSource();

				// 初始化context的事件传播器
				initApplicationEventMulticaster();

				// 初始化其它子类特殊的bean
				onRefresh();

				// 检查并注册事件监听器
				registerListeners();

				// 实例化所有非懒加载单例
				finishBeanFactoryInitialization(beanFactory);

				// Last step: 发布对应事件
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}   
在上面的代码中，调用finishRefresh方法初始化容器的生命周期处理器并发布容器的生命周期事件之后，
Spring应用上下文正式开启，Spring Boot核心特性(自动配置)也随之启动。

完成refreshContext方法操作之后，调用afterRefresh方法。新版本的Spring Boot中refreshContext
方法的实现默认为空，可由开发人员自行扩展。但需要注意的是，该方法在以往的版本中方法定义和
实现差距较大，如果对此方法进行扩展，在升级版本时需特别留意。
protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {
	}
完成以上操作之后，调用SpringApplicationRunListeners的started方法，通知监听器容器启动完成，
并调用ApplicationRunner和CommandLineRunner的运行方法。

</pre>

### 这一步会进行自动配置
- NOTE
<pre>参见 自动配置源码调用图.png</pre>

## 调用ApplicationRunner和CommandLineRunner
- NOTE
<pre>ApplicationRunner和CommandLineRunner是通过SpringApplication类的callRunners方法来完成的
callRunners(context, applicationArguments);

首先从context中获得类型为ApplicationRunner和CommandLineRunner的Bean，将它们放入
List列表中并进行排序。然后再遍历调用其run方法，并将ApplicationArguments参数传入。

Spring Boot提供这两个接口的目的，是为了我们在开发的过程中，通过它们来实现在容器启动时
执行一些操作，如果有多个实现类，可通过@Order注解或实现Ordered接口来控制执行顺序。

这两个接口都提供了一个run方法，但不同之处在于：ApplicationRunner中run方法的参数为
ApplicationArguments，而CommandLineRunner接口中run方法的参数为String数组。
以上方法执行完成后，会调用SpringApplicationRunListeners的running方法通知监听器：
容器此刻已处于运行状态。至此，SpringApplication的run方法执行完毕。</pre>
