Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot外化配置解析
- NOTE
<pre>Spring Boot允许我们将配置进行外部化处理，以便我们使用相同的代码在不同的环境中运行。
我们可以使用属性文件、YAML文件、环境变量和命令参数来进行外化配置。这些配置中的属性可以
通过@Value注解直接注入到对应的Bean中，也可以通过Spring的Environment抽象访问，还可以
通过@ConfigurationProperties绑定到结构化的对象上。

Spring Boot设计了非常特殊的加载指定属性文件（PropertySource）的顺序，以允许对属性值进行
合理的覆盖。属性值会以下面的优先级进行设置：
·home目录下的Devtools全局设置属性（~/.spring-boot-devtools.properties，条件是当
devtools激活时）。
·@TestPropertySource注解的测试用例。
·@SpringBootTest#properties注解的测试用例。
·命令行参数。
·来自SPRING_APPLICATION_JSON的属性（内嵌在环境变量或系统属性中的内联JSON）。
·ServletConfig初始化参数。
·ServletContext初始化参数。
·java:comp/env的JNDI属性。
·Java系统属性（System.getProperties()）。
·操作系统环境变量。
·RandomValuePropertySource，只包含random.*中的属性。
·jar包外的Profile-specific应用属性（application-{profile}.properties和YAML变量）。
·jar包内的Profile-specific应用属性（application-{profile}.properties和YAML变量）。
·jar包外的应用配置（application.properties和YAML变量）。
·jar包内的应用配置（application.properties和YAML变量）。
·@Configuration类上的@PropertySource注解。
·默认属性（通过SpringApplication.setDefaultProperties指定）。

在以上配置方式中，我们经常使用的包括：命令参数、属性文件、YAML文件等内容。</pre>

## ApplicationArguments参数处理
- NOTE
<pre>ApplicationArguments提供了针对参数的解析和查询功能。在Spring Boot运行阶段中我们提到过，
通过SpringApplication.run(args)传递的参数会被封装在ApplicationArguments接口中。

1、接口定义及初始化
public interface ApplicationArguments {

	/**
	 * 返回原始未处理的参数(通过application传入的) 
	 */
	String[] getSourceArgs();

	/**
	 * 返回所有参数名称的集合，比如参数为：--foo=bar -- debug，则返回[&quot;foo&quot;, &quot;debug&quot;]
	 */
	Set&lt;String&gt; getOptionNames();

	/**
	 * 选项参数中是否包含指定名称的参数
	 */
	boolean containsOption(String name);

	/**
	 * 根据选项参数的名称获取选项参数的值列表
	 */
	List&lt;String&gt; getOptionValues(String name);

	/**
	 * 返回非选项参数列表
	 */
	List&lt;String&gt; getNonOptionArgs();

}

通过接口定义可以看出，ApplicationArguments主要提供了针对参数名称和值的查询，以及判断是
否存在指定参数的功能。

在Spring Boot的初始化运行过程中，ApplicationArguments接口的实例化操作默认是通过实现类
DefaultApplicationArguments来完成的。DefaultApplicationArguments的底层又是基于
Spring框架中的命令行配置源SimpleCommandLinePropertySource实现的。
SimpleCommandLinePropertySource是PropertySource抽象类的派生类。

ApplicationArguments，或者更进一步说是SimpleCommandLinePropertySource对参数类型是
有所区分的，即选项参数和非选项参数。
选项参数必须以“--”为前缀，参数值可为空，该参数我们可以通过SpringBoot属性处理后使用，
比如在执行jar -jar命令时，添加选项参数“--app.name=spring boot learn”，在代码中可通过
@Value属性或其他方式获取到该参数的值。该参数可以通过逗号分隔多个参数值，
或多次使用同一个参数来包含多个参数的值。
非选项参数并不要求以“--”前缀开始，可自行定义。非选项参数可以是除了传递的VM参数之外的
其他参数。比如我们可以直接在jar -jar命令中定义参数为“non-option”的参数值。

以上所说的选项参数和非选项参数的解析是在SimpleCommandLinePropertySource构造方法中调用
的SimpleCommandLineArgsParser中完成的。

通过SimpleCommandLineArgsParser的代码可以看出，Spring对参数的解析是按照指定的参数
格式分别解析字符串中的值来实现的。最终，解析的结果均封装在CommandLineArgs中。
而CommandLineArgs类只是命令行参数的简单表示形式，内部分为“选项参数”和“非选项参数”。

CommandLineArgs的核心存储结构包括：存储选项参数的Map&lt;String,List&lt;String&gt;&gt; optionArgs
和存储非选项参数的List&lt;String&gt;nonOptionArgs。同时，针对这两个核心存储结构，
Spring Boot也提供了读写操作的方法。

SimpleCommandLineArgsParser解析获得的CommandLineArgs对象，最终会被
SimpleCommand-LinePropertySource的构造方法通过super调用，一层层地传递到
PropertySource类的构造方法，最终封装到对应的属性当中。

以在SimpleCommandLinePropertySource中的使用为例，最终封装在PropertySource中的结构为：
name为“commandLineArgs”，source为解析出的CommandLineArgs对象。
而DefaultApplicationArguments的内部类Source作为SimpleCommandLinePropertySource的
子类存储了以上解析的数据内容。同时，args参数的原始值存储在DefaultApplicationArguments
的String[ ]args属性中。

2、使用实例
在实践中我们可能会遇到这样的疑问：如何访问应用程序变量？或者，如何访问通过
SpringApplication.run(args)传入的参数？下面我们以具体的例子来说明如何通过
ApplicationArguments获得对应的参数。ApplicationArguments接口的使用非常简单，
在我们使用参数值的Bean中直接注入ApplicationArguments即可，然后调用其方法即可
获得对应的参数值。

选项参数可通过@Value直接注入Bean中使用。
</pre>

## 命令参数的获取
> leftSide=`true`

- NOTE
<pre>命令行参数就是在启动Spring Boot项目时通过命令行传递的参数。比如，用如下命令来启动一个Spring Boot的项目。
java -jar app.jar --name=SpringBoot

那么，参数--name=SpringBoot是如何一步步传递到Spring内部的呢？
默认情况下，SpringApplication会将以上类似name的命令行参数（以“--”开通）解析封装成一个
PropertySource对象，并将其添加到Spring-Environment当中，而命令行参数的优先级要
高于其他配置源。

下面，我们通过代码来追踪启动过程中整个参数的获取、解析和封装过程。首先，参数是通过
SpringApplication的run方法的args参数来传递的。
在SpringApplication的run方法中，先将args封装于对象ApplicationArguments中，
然后又将封装之后的对象传递入prepareEnvironment方法。
在prepareEnvironment方法中，通过applicationArguments.getSourceArgs()获得传递的参数
数组，并作为参数调用configureEnvironment方法，此处获得的args依旧是未解析的参数值。
在configureEnvironment方法中又将参数传递给configurePropertySources方法。
而在configurePropertySources方法中才对参数进行了真正的解析和封装。

参数的优先级和命令行参数的解析：
configurePropertySources方法第一步获得环境变量中存储配置信息的sources；第二步判断默认
参数是否为空，如果不为空，则将默认参数放置在sources的最后位置，
这里已经明显反映了参数的优先级是通过顺序来体现的；第三步，如果命令参数未被禁用，
且不为空，则要么将原有默认参数替换掉，要么直接放在第一位，这一步中的替换操作也是
另外一种优先级形式的体现。
顺便提一下，在上面的代码中，addCommandLineProperties参数是可以进行设置的，
当不允许使用命令行参数时，可以通过SpringApplication的setAddCommandLineProperties
方法将其设置为false来禁用。
命令行参数的解析用到了SimpleCommandLinePropertySource类。
</pre>

## 配置文件的加载
> leftSide=`true`

- NOTE
<pre>Spring Boot启动时默认会加载classpath下的application.yml或application.properties文件。
配置文件的加载过程主要是利用Spring Boot的事件机制来完成的，也就是我们所讲到的
SpringApplicationRunListeners中的environmentPrepared方法来启动加载配置文件的事件。
通过该方法发布的事件会被注册的ConfigFileApplicationListener监听到，从而实现资源的加载。

下面，我们通过源代码的追踪来分析这一过程。该事件同样是在SpringApplication的run方法中
来完成的。前半部分的调用过程与命令行参数获取的方法调用一样，不同的是当执行到
prepareEnvironment中，当执行完configureEnvironment方法之后，便通过事件发布来通知
监听器加载资源。

该事件监听器通过EventPublishingRunListener的environmentPrepared方法来发布一个
ApplicationEnvironmentPreparedEvent事件。
@Override
	public void environmentPrepared(ConfigurableEnvironment environment) {
		this.initialMulticaster
				.multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));
	}
在META-INF/spring.factories中注册的ConfigFileApplicationListener会监听到对应事件，并进行相应的处理。

在ConfigFileApplicationListener类中我们会看到很多与配置文件加载相关的常量。
我们通过这些基本的常量，已经可以看出默认加载配置文件的路径和默认的名称了。再回到刚才的
事件监听，入口方法为ConfigFileApplicationListener的onApplicationEvent方法。
@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationEnvironmentPreparedEvent) {
			onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
		}
		if (event instanceof ApplicationPreparedEvent) {
			onApplicationPreparedEvent(event);
		}
	}
上面代码中调用的onApplicationEnvironmentPreparedEvent方法如下，该方法会获得注册的处理器，
遍历并依次调用其postProcessEnvironment方法。
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
		List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();
		postProcessors.add(this);
		AnnotationAwareOrderComparator.sort(postProcessors);
		for (EnvironmentPostProcessor postProcessor : postProcessors) {
			postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());
		}
	}
其中EnvironmentPostProcessor接口的实现类也是在META-INF/spring.factories文件中注册的。

ConfigFileApplicationListener本身也是EnvironmentPostProcessor接口的实现类。我们跟着
ConfigFileApplicationListener中postProcessEnvironment的调用链路代码一直往下看，
会发现最后在其内部类Loader的load方法中进行配置文件的加载操作。

在该方法中可以看到loadForFileExtension的第二个参数“文件路径+名称”和第三个参数“扩展名称”的
拼接组成方式。location默认值就是常量DEFAULT_SEARCH_LOCATIONS的值。在for循环中遍历
的PropertySourceLoader也是在META-INF/spring.factories中注册的，并且在Loader的构造方
法中通过SpringFactoriesLoader的loadFactories方法来获得。

当查看PropertiesPropertySourceLoader和YamlPropertySourceLoader两个加载器代码时，就会
发现它们分别定义了所支持文件类型及其加载方法。

其中PropertiesPropertySourceLoader对文件的加载通过PropertiesLoaderUtils类（加载xml文件）
和OriginTrackedPropertiesLoader类来完成，而YamlPropertySourceLoader对文件的加载主要
通过OriginTrackedYamlLoader来完成。




</pre>

## Profile
- NOTE
<pre>在日常使用中我们可以通过配置spring.profiles.active指定一组不同环境的配置文件，比如
application-dev.properties、application-test.properties、application-prod.properties。
那么，profile是如何被加载使用的呢？本节重点分析一下ConfigFileApplicationListener类中基于
profile的文件加载处理逻辑。

在ConfigFileApplicationListener类中单独定义了一个内部类Profile用来存储profile的相关信息，
该类只有两个核心字段：name用来表示profile文件的名称；defaultProfile用来表示profile是否为
默认的。

在ConfigFileApplicationListener类的逻辑处理中（除了关于配置文件的具体加载）都离不开profile
的参与。我们先从内部私有类Loader的load方法开始， 主要逻辑就是在initializeProfiles方法里面。
在这个初始化的过程中，initializeProfiles首先会给profiles添加一个优先级最低的null值，
然后判断spring.profiles.active、spring.profiles.include属性配置的profile，如果存在配置项
则激活activatedProfiles配置。如果不存在，则profiles的长度为1，进入设置默认的profile配置。
当initializeProfiles方法执行完成后，程序执行回到主代码逻辑，此时会遍历profiles中的值，
并逐一进行load操作。处理完成的会单独放在processedProfiles中，最后再次加载profile为null的配置，
加载PropertySource到环境中。

</pre>

## 综合实战
> leftSide=`true`

- NOTE
<pre>我们通过一个具体的例子来简单演示在Spring Boot中如何使用不同类型的参数及配置。
本实例涉及的部分新知识点我们也会进行简单地介绍和拓展。在本实例中，我们会用到命令行传递
参数、默认配置文件application.properties及基于profile配置参数、@Value注解获取参数、
基于类型安全的@ConfigurationProperties注解关联Bean等功能。

SpringBoot将Environment属性绑定到@ConfigurationProperties标注的Bean时，还可以使用
一些宽松的规则，也就是说Environment属性名和Bean属性名不需要精确匹配。
比如在对象User中有一个firstName属性，那么在配置文件中对应如下配置项均会匹配：
user.firstName // 标准驼峰命名语法
user.first-name // 推荐用于.properties和.yml文件中
user.first_name // 用于.properties和.yml文件的可选格式
USER_FIRST_NAME // 推荐用于系统环境变量</pre>
