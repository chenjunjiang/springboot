Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot内置Servlet容器

## Web容器自动配置
- NOTE
<pre>1、Servlet Web
Spring Boot Servlet Web构成.png
图中第一列为Servlet容器名称，表示Spring Boot内置支持的Web容器类型，目前包括
Tomcat、Jetty、Undertow。第二列为针对不同的Web容器的WebServer实现类，
用于控制Web容器的启动和停止等操作。第三列为创建第二列中具体WebServer的工厂方法类。

以上Servlet容器相关支持类均位于spring-boot项目的org.springframework.boot.web包下，
而以上容器的具体实现位于org.springframework.boot.web.embedded下。
以Tomcat为例，通过自动配置先初始化TomcatServletWebServerFactory工厂类，
在Spring Boot启动过程中，该工厂类会通过其getWebServer方法创建TomcatWebServer实例，
启动Tomcat等一系列操作。

2、自动配置源码分析
在Spring Boot中，Servlet Web容器的核心配置就是上面提到的3个工厂方法的实例化和
BeanPostProcessor的注册。
在讲DispatcherServletAutoConfiguration自动配置时，我们并没有详细讲解其中的
@AutoConfigureAfter注解，该注解内指定的类为ServletWebServerFactoryAutoConfiguration，
即在完成了Web Server容器的自动配置之后，才会进行DispatcherServlet的自动配置。
而本节要讲的内容就是从ServletWebServerFactoryAutoConfiguration开始的。

ServletWebServerFactoryAutoConfiguration是用来自动配置Servlet的Web服务的。
@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(ServerProperties.class)
@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
public class ServletWebServerFactoryAutoConfiguration {
......
}

注解中常规的项就不多说了，我们重点看一下@Import注解中引入的内容。该注解引入了当前类的
内部类BeanPostProcessorsRegistrar和ServletWebServerFactoryConfiguration的3个内部类：
EmbeddedTomcat、EmbeddedJetty、EmbeddedUndertow。
先来看ServletWebServerFactoryConfiguration类，它是Servlet Web服务器的配置类，
目前该类中包含了内置Tomcat、Jetty和Undertow的配置，重点作用就是实例化对应的工厂类。

ServletWebServerFactoryConfiguration类中定义的3个内部类，一般通过@Import注解在其他自动
配置类中引入使用，并确保其执行顺序。在ServletWebServerFactoryAutoCon-figuration中的使用
便是实例。
ServletWebServerFactoryConfiguration中具体工厂Bean的初始化操作基本相同，都是在方法内
通过new创建对应的工厂类，设置其初始化参数，然后注入Spring容器中。下面我们以其中最常用
的Tomcat容器为例来进行源码层面的讲解。

EmbeddedTomcat自动配置的条件是类路径中存在Servlet、Tomcat、UpgradeProtocol这3个类，
并且ServletWebServerFactory不存在。
需要注意@ConditionalOnMissingBean注解的search属性。
@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
search属性支持的搜索策略类型定义在枚举类SearchStrategy中，包括CURRENT、ANCESTORS、
ALL。这3种策略类型依次对应的作用范围为：搜索当前容器、搜索所有祖先容器（不包括当前容器）
、搜索所有层级容器。默认情况下，search属性的值为ALL，也就是搜索所有层级容器，
而此处Search属性是CURRENT，即搜索范围是当前容器。(这里是指Spring容器)

TomcatServletWebServerFactory的实例化方法tomcatServletWebServerFactory是由3个
ObjectProvider参数构成。ObjectProvider参数中的泛型依次包括TomcatConnectorCustomizer、
TomcatContextCustomizer和TomcatProtocolHandlerCustomizer&lt;?&gt;，它们均为回调接口。
TomcatConnectorCustomizer用于Tomcat Connector的定制化处理，TomcatContextCustomizer
用于Tomcat Context的定制化处理，TomcatProtocolHandlerCustomizer&lt;?&gt;用于
Tomcat Connector中ProtocolHandler的定制化处理。也就是说，通过以上回调函数，
可以在核心业务处理完成之后，针对Tomcat再进行一些定制化操作。



</pre>

### ObjectProvider
- NOTE
<pre>在Spring4.3之前，如果你构造函数中要依赖另外一个bean，你必须显示依赖@Autowired
（这里不考虑使用了自动注入的方式，像这样子：
@Service
public class FooService {
    private final FooRepository repository;
    @Autowired
    public FooService(FooRepository repository) {
        this.repository = repository
    }
}
而在4.3版本之后，已经不需要这么做了，只要我们只提供了一个构造函数，并且构造函数所需要的
参数都在Spring容器中（实际上官网中也指出，如果依赖关系是强制的，那么最好使用构造函数进行
注入），那么不需要进行精确的指定使用@Autowired。相比于4.3版本这无疑简化了我们的开发，
但是这种隐式的注入仍然存在一些不足。例如，就上面的例子而言，如果容器中存在了一个以上的
FooRepository甚至一个都没有的情况下，抛出异常
Parameter 0 of constructor in com.example.demo.FooServicerequired a bean of type
 ‘com.example.demo.FooRepository’ that could not be found.
或者是
No qualifying bean of type ‘com.example.demo.FooRepository’’ available: expected single 
matching bean but found 2:

那么我们有什么办法解决它呢？基于这个原因，ObjectProvider就出场了。如果注入实例为空时，
使用ObjectProvider则避免了强依赖导致的依赖对象不存在异常；如果有多个实例，
ObjectProvider的方法可以根据Bean实现的Ordered接口或@Order注解指定的先后顺序获取一个
Bean。从而了提供了一个更加宽松的依赖注入方式。

ObjectProvider解决的问题
容器中没有Bean时，抛出Parameter 0 of constructor in com.example.demo.FooServicerequired a bean of type 'com.example.demo.FooRepository' that could not be found.。
解决方式：
@Component
public class IndexService {
	B b;
    public IndexService(ObjectProvider&lt;B&gt; b) {
		this.b = b.getIfAvailable();
	}
}
但是上面这种解决方式的弊病也很明显，就是b可能为空，则可能将异常从启动阶段转移到业务运行
阶段。

问题二
容器中存在多个Bean时，抛出No qualifying bean of type 'com.example.demo.FooRepository'' available: expected single matching bean but found 2
解决方式：
@Component
public class IndexService {
	B b;
	public IndexService(ObjectProvider&lt;B&gt; b) {
		this.b = b.orderedStream().findFirst().orElse(null);
	}
}
当容器存在多个Bean，我们可以调用它的流式方法获取一个自己想要的依赖。</pre>

## WebServer初始化过程
> leftSide=`true`

- NOTE
<pre>
WebServer接口的源代码如下：
public interface WebServer {

	/**
	 * Starts the web server. Calling this method on an already started server has no
	 * effect.
	 * @throws WebServerException if the server cannot be started
	 */
	void start() throws WebServerException;

	/**
	 * Stops the web server. Calling this method on an already stopped server has no
	 * effect.
	 * @throws WebServerException if the server cannot be stopped
	 */
	void stop() throws WebServerException;

	/**
	 * Return the port this server is listening on.
	 * @return the port (or -1 if none)
	 */
	int getPort();

}
接口定义了3个方法：start方法为启动容器，stop方法为停止容器，getPort方法为获得容器端口。

现在以Tomcat的启动为例来说明整个内置容器的加载与启动。在上节中，工厂类已经被自动配置
初始化。那么，在什么地方用到它们的呢？这要回到最初Spring Boot启动的过程中。还记得
SpringApplication的run方法中有一个调用初始化容器的方法refreshContext吗？
我们就从这个方法开始追踪。
在ServletWebServerApplicationContext的
@Override
	protected void onRefresh() {
		super.onRefresh();
		try {
			createWebServer();
		}
		catch (Throwable ex) {
			throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
		}
	}
方法里面会调用createWebServer(); 这里面对WebServer进行初始化。

如果是Tomcat， 那么会初始化TomcatWebServer
public TomcatWebServer(Tomcat tomcat, boolean autoStart) {
		Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;);
		this.tomcat = tomcat;
		this.autoStart = autoStart;
		initialize();
	}
initialize()方法是关键，该方法最后调用了startDaemonAwaitThread();与Jetty不同，所有Tomcat
线程都是守护线程。这里创建一个非守护线程防止启动后立即关闭
</pre>

## 　DispatcherServlet的加载过程
> leftSide=`true`

- NOTE
<pre>1、DispatcherServlet的获取
在ServletWebServerApplicationContext#createWebServer方法中，调用ServletWebServerFactory
的getWebServer方法时，传递的参数是通过getSelfInitializer方法获得的，这也是获取
DispatcherServlet的入口方法。

DispatcherServlet的加载
要追踪ServletContextInitializer匿名类（被存储在变长参数initializers中）何时被调用，还要回到
ServletWebServerApplicationContext的createWebServer方法中，这里将initializers作为参数传入
了ServletWebServerFactory的getWebServer方法。</pre>

## 综合实战
- NOTE
<pre>使用最多的场景就是通过application配置文件对Servlet容器进行一些定制化的参数配置，配置参数
对应于ServerProperties类中的属性。

我们基于源代码了解了Servlet的基本流程和内部原理，可以通过代码的形式来对Servlet容器进行配置。
首先，可以通过源码中提到的WebServerFactoryCustomizer接口来实现代码形式的定制化配置。
@Component
public class CustomServletContainer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {
    @Override
    public void customize(ConfigurableServletWebServerFactory factory) {
        factory.setPort(8081);
    }
}
通过上述方式修改代码之后，我们再次启动项目，项目端口已经变为8081了。同样的，也可以针对
factory的其他属性进行配置（调用对应的set方法）。如果上述配置也无法满足业务需求，则可通过
进一步实现容器的工厂方法进行定制化操作。
比如，Tomcat、Jetty、Undertow容器的定制化可分别注册TomcatServletWebServerFactory、
JettyServletWebServerFactory、UndertowServletWebServerFactory对应的Factory来实现。
下面以Tomcat的基本配置为例进行讲解：
代码参见：TomcatConfig
通过创建TomcatServletWebServerFactory的对象，并进行具体参数的设置来完成容器的自定义。
在本节两个示例中，需要注意的是，如果Servlet容器的端口和Tomcat的端口同时配置，
则Tomcat的端口不会生效。

通过上述两种形式都可以对内置容器进行定制化配置，但一般情况下，采用默认配置或通过属性配置
即可。如果上述两种配置都无法满足需求，可考虑不使用内置容器，而是将项目打包成可发布到
外部容器的WAR形式。
</pre>
