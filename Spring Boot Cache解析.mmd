Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot Cache
- NOTE
<pre>Spring Boot支持了多种缓存的自动配置，其中包括Generic、JCache、EhCache 2.x、Hazelcast、
Infinispan、Couchbase、Redis、Caffeine和Simple。早期版本还支持Guava的缓存，
但目前已经废弃。
本章将重点讲解缓存的自动配置CacheAutoConfiguration和默认的SimpleCacheConfiguration
自动配置及相关内容。</pre>

## Cache简介
- NOTE
<pre>随着项目的发展，往往会出现一些瓶颈，比如与数据库的交互、与远程服务器的交互等。此时，
缓存便派上了用场。而在Spring 3.1中引入了基于注解的Cache的支持，在spring-context包中定义了
org.springframework.cache.CacheManager和org.springframework.cache.Cache接口，用来统一
不同的缓存的技术。CacheManager是Spring提供的各种缓存技术管理的抽象接口，而Cache接口包含
缓存的增加、删除、读取等常用操作。针对CacheManager，Spring又提供了多种实现，比如基于
Collection来实现的SimpleCacheManager、基于ConcurrentHashMap实现的
ConcurrentMapCacheManager、基于EhCache实现的EhCacheCacheManager和基于JCache标准
实现的JCacheCacheManager等。

Spring Cache的实现与Spring事务管理类似，都是基于AOP的方式。其核心思想是：第一次调用缓存
方法时，会把该方法参数和返回结果作为键值存放在缓存中，当同样的参数再次请求方法时不再执行
该方法内部业务逻辑，而是直接从缓存中获取结果并返回。

Spring Cache提供了@CacheConfig、@Cacheable、@CachePut、@CacheEvict等注解来
完成缓存的透明化操作，相关功能如下。
·@CacheConfig：用于类上，缓存一些公共设置。
·@Cacheable：用于方法上，根据方法的请求参数对结果进行缓存，下次读取时直接读取缓存内容。
·@CachePut：用于方法上，能够根据方法的请求参数对其结果进行缓存，和@Cacheable不同的是，
它每次都会触发真实方法的调用。
·@CacheEvict：用于方法上，清除该方法的缓存，用在类上清除整个类的方法的缓存。

</pre>

## Cache自动配置
> leftSide=`true`

- NOTE
<pre>在Spring Boot中，关于Cache的默认自动配置类只有CacheAutoConfiguration，主要用于缓存抽象
的自动配置，当通过@EnableCaching启用缓存机制时，根据情况可创建CacheManager。
对于缓存存储可以通过配置自动检测或明确指定。CacheAutoConfiguration同样在
META-INF/spring.factories文件中配置注册。
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration

@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(CacheManager.class)
@ConditionalOnBean(CacheAspectSupport.class)
@ConditionalOnMissingBean(value = CacheManager.class, name = &quot;cacheResolver&quot;)
@EnableConfigurationProperties(CacheProperties.class)
@AutoConfigureAfter({ CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class,
		HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class })
@Import({ CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class })
public class CacheAutoConfiguration {
}
@ConditionalOnClass指定需要在classpath下存在CacheManager类。关于CacheManager类是一个
缓存管理器的接口，管理各种缓存（Cache）组件。针对不同的缓存技术，会有不同的实现类。
比如，在Spring中提供了SimpleCacheManager（测试）、
ConcurrentMapCacheManager（默认）、NoOpCacheManager（测试）、
EhCacheCacheManager（基于EhCache）、RedisCacheManager（基于Redis）等实现类。

CacheManager接口提供了两个方法：根据名称获取缓存和获取缓存名称集合:
public interface CacheManager {

	/**
	 * 根据名称获取缓存
	 */
	@Nullable
	Cache getCache(String name);

	/**
	 * 获取缓存名称集合
	 */
	Collection&lt;String&gt; getCacheNames();

}

在CacheManager接口中只定义了上面两个方法，但在其抽象实现类AbstractCacheManager中便
扩展了新增Cache、更新Cache等方法。

@ConditionalOnBean指定需要存在CacheAspectSupport的Bean时才生效，换句话说，
就是需要在使用了@EnableCaching时才有效。这是因为该注解隐式的导致了CacheInterceptor对应
的Bean的初始化，而CacheInterceptor为CacheAspectSupport的子类。
使用@EnableCaching后，XxCacheConfiguration配置类里面的CacheManager才会被初始化，
比如：RedisCacheConfiguration里面就会初始化RedisCacheManager，这样我们就可以使用
spring基于AOP提供的缓存机制了，比如：https://blog.csdn.net/weixin_44971379/article/details/106605772
如果我们需要手动管理redis缓存，那么我们不需要使用@EnableCaching，直接使用RedisAutoConfiguration
里面的RedisTemplate即可。

@ConditionalOnMissingBean指定名称为cacheResolver的CacheManager对象不存在时生效。
@EnableConfigurationProperties加载缓存的CacheProperties配置项，配置前缀为spring.cache。
@AutoConfigureAfter指定该自动配置必须在缓存数据基础组件自动配置之后进行，这里包括
Couchbase、Hazelcast、HibernateJpa和Redis的自动配置。

想要实现缓存，需要先集成对应的缓存框架或组件。这里以Redis为例，它的自动配置类
RedisAutoConfiguration中便完成了Redis相关的RedisTemplate和StringRedisTemplate的实例化。
而RedisAutoConfiguration中导入类JedisConnectionConfiguration又完成了Redis使用Jedis连接
的配置。

@Import导入CacheConfigurationImportSelector，其实是导入符合条件的Spring Cache使用的
各类基础缓存框架（或组件）的配置。该类的实现就位于CacheAutoConfiguration中
导入类的获取是通过实现ImportSelector接口来完成的，具体获取步骤位于selectImports方法中。
该方法中，首先获取枚举类CacheType中定义的缓存类型数据，CacheType中定义支持的缓存类型如下。
public enum CacheType {

	/**
	 * Generic caching using 'Cache' beans from the context.
	 */
	GENERIC,

	/**
	 * JCache (JSR-107) backed caching.
	 */
	JCACHE,

	/**
	 * EhCache backed caching.
	 */
	EHCACHE,

	/**
	 * Hazelcast backed caching.
	 */
	HAZELCAST,

	/**
	 * Infinispan backed caching.
	 */
	INFINISPAN,

	/**
	 * Couchbase backed caching.
	 */
	COUCHBASE,

	/**
	 * Redis backed caching.
	 */
	REDIS,

	/**
	 * Caffeine backed caching.
	 */
	CAFFEINE,

	/**
	 * Simple in-memory caching.
	 */
	SIMPLE,

	/**
	 * No caching.
	 */
	NONE

}

枚举类CacheType中定义了以上支持的缓存类型，而且上面的缓存类型默认是按照优先级从前到后的顺序排列的。
selectImports方法中，当获取CacheType中定义的缓存类型数组之后，遍历该数组并通过
CacheConfigurations的getConfigurationClass方法获得每种类型缓存对应的自动配置类
（注解@Configuration的类）。
经过以上步骤，我们会发现通过@Import注解，CacheAutoConfiguration导入了CacheType中定义
的所有类型的自动配置，也就是Spring Boot目前支持的缓存类型。
而具体会自动配置哪种类型的缓存，还需要看导入的自动配置类里面的生效条件。

我们以GenericCacheConfiguration为例进行了解


</pre>

## 默认Cache配置
> leftSide=`true`

- NOTE
<pre>当使用@EnableCaching启动Spring Boot的缓存机制但又未添加其他缓存类库时，Spring Boot会
默认提供一个基于ConcurrentHashMap实现的缓存组件——ConcurrentMapCacheManager。
但官方文档已经明确提示，不建议在生产环境中使用该缓存组件。但它却是一个很好的学习
缓存特性的工具。

这个默认的缓存组件是通过SimpleCacheConfiguration来完成自动配置的。

@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class SimpleCacheConfiguration {

	@Bean
	ConcurrentMapCacheManager cacheManager(CacheProperties cacheProperties,
			CacheManagerCustomizers cacheManagerCustomizers) {
		ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
		List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();
		if (!cacheNames.isEmpty()) {
			cacheManager.setCacheNames(cacheNames);
		}
		return cacheManagerCustomizers.customize(cacheManager);
	}

}

该自动配置文件很简单，当容器中不存在CacheManager的Bean，同时满足CacheCondition中指定‘
的条件时，则进行自动配置。
在cacheManager方法中首先创建了一个ConcurrentMapCacheManager对象，然后通过配置属性
类获得缓存名称列表，如果列表内容不为空，则赋值给上述对象cacheManager。最后调用
CacheManagerCustomizers的customize方法对cacheManager进行定制化处理并返回。

</pre>

## @EnableCaching
- NOTE
<pre>https://blog.csdn.net/weixin_44971379/article/details/106605772

如果需要自己手动管理缓存的话，不需要使用这个注解。</pre>

## @Conditional
> leftSide=`true`

- NOTE
<pre>https://www.cnblogs.com/haha12/p/11304738.html

@Conditional是Spring4新提供的注解，它的作用是根据某个条件创建特定的Bean，通过实现
Condition接口，并重写matches接口来构造判断条件(返回true表示满足条件，false表示不满足)。
总的来说，就是根据特定条件来控制Bean的创建行为，这样我们可以利用这个特性进行一些自动的配置。

public class WindowsCondition implements Condition {
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return context.getEnvironment().getProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
    }
}

public class LinuxCondition implements Condition {
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return context.getEnvironment().getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;);
    }
}

public interface ListService {

    public String showListCmd();

}

public class WindowsService implements ListService {
    public String showListCmd() {
        return &quot;dir&quot;;
    }
}

public class LinuxService implements ListService {
    public String showListCmd() {
        return &quot;ls&quot;;
    }
}

@Configuration
public class Config {

    @Bean
    @Conditional(WindowsCondition.class)
    public ListService window() {
        return new WindowsService();
    }

    @Bean
    @Conditional(LinuxCondition.class)
    public ListService linux() {
        return new LinuxService();
    }
}

三、@Conditional的扩展注解
@ConditionalOnBean：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。
@ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。
@ConditionalOnExpression：当表达式为true的时候，才会实例化一个Bean。
@ConditionalOnMissingBean：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。
@ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。
@ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。
@ConditionalOnBean：当容器中有指定Bean的条件下进行实例化。
@ConditionalOnMissingBean：当容器里没有指定Bean的条件下进行实例化。
@ConditionalOnClass：当classpath类路径下有指定类的条件下进行实例化。
@ConditionalOnMissingClass：当类路径下没有指定类的条件下进行实例化。
@ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。
@ConditionalOnNotWebApplication：当项目不是一个Web项目时进行实例化。
@ConditionalOnProperty：当指定的属性有指定的值时进行实例化。
@ConditionalOnExpression：基于SpEL表达式的条件判断。
@ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。
@ConditionalOnResource：当类路径下有指定的资源时触发实例化。
@ConditionalOnJndi：在JNDI存在的条件下触发实例化。
@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。

</pre>
