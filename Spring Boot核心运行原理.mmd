Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot核心运行原理
- NOTE
<pre>Spring Boot最核心的功能就是自动配置，功能的实现都是基于“约定优于配置”的原则。
使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，
配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，
这便是Spring Boot的自动配置功能。

可以用一句话来描述整个过程：
Spring Boot通过@EnableAutoConfiguration注解开启自动配置，
加载spring.factories中注册的各种AutoConfiguration类，
当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、
配置或Spring容器中是否存在某个Bean等）时，
实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，
就可以完成依赖框架的自动配置。</pre>

## @EnableAutoConfiguration
- NOTE
<pre>该注解由组合注解@SpringBootApplication引入，完成自动配置开启，
扫描各个jar包下的spring.factories文件，并加载文件中注册的AutoConfiguration类等。

@EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，
它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义
的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。
举个例子：如果将tomcat-embedded.jar添加到classpath下，那么@EnableAutoConfiguration
会认为你准备使用TomcatServletWebServerFactory类，并帮你初始化相关配置。与此同时，
如果自定义了基于ServletWebServerFactory的Bean，那么@EnableAutoConfiguration将不会进行
TomcatServletWebServerFactory类的初始化。这一系列的操作判断都由Spring Boot来完成。

需要注意的是，被@EnableAutoConfiguration注解的类所在package还具有特定的意义，
通常会被作为扫描注解@Entity的根路径。这也是在使用@SpringBootApplication注解时需要将被
注解的类放在顶级package下的原因，如果放在较低层级，它所在package的同级或上级中的类
就无法被扫描到。而对于入口类和其main方法来说，并不依赖@SpringBootApplication注解
或@EnableAutoConfiguration注解，也就是说该注解可以使用在其他类上，而非入口类上。比如：
public static void main(String[] args) {
        // 这里的class参数不一定就是Application，只要是有@SpringBootApplication注解类都可以
        SpringApplication.run(Application.class, args);
    }</pre>

### @SpringBootApplication
- NOTE
<pre>Spring Boot项目创建完成会默认生成一个*Application的入口类。
在默认情况下，无论是通过IDEA还是通过官方创建基于Maven的Spring Boot项目，
入口类的命名规则都是artifactId+Application。通过该类的main方法即可启动Spring Boot项目。
在Spring Boot入口类（除单元测试外）中，唯一的一个注解就是@SpringBootApplication。
它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。</pre>

#### proxyBeanMethods 
- NOTE
<pre>proxyBeanMethods是为了让使用@Bean注解的方法被代理而实现bean的生命周期的行为。
1.设置为true，那么直接调用方法获取bean，不会创建新的bean，而是会走bean的生命周期的行为。
2.设置为false, 那么直接调用方法获取bean，会创建新的bean，且不会走bean的生命周期的行为。
如果你的 @Bean 方法之间没有调用关系的话可以把 proxyBeanMethods 设置为 false。这样配置类不会被代理了
(如果代理会用到CGLIB)，这样能提高性能，配置类和方法也可以使用 final 修饰了。
参考AnnotationConfigApplicationContextTest这个测试例子就明白了。</pre>

#### @AliasFor

### @Import
- NOTE
<pre>@Import注解位于spring-context项目内，主要提供导入配置类的功能。
@Import的作用和xml配置中&lt;import/&gt;标签的作用一样，我们可以通过@Import引入
@Configuration注解的类，也可以导入实现了ImportSelector或ImportBeanDefinitionRegistrar的类，
还可以通过@Import导入普通的POJO（将其注册成Spring Bean，导入POJO需要Spring 4.2以上版本）。</pre>

### ImportSelector接口
- NOTE
<pre>@Import的许多功能都需要借助接口ImportSelector来实现，ImportSelector决定可引入哪些@Configuration。

ImportSelector接口只提供了一个参数为AnnotationMetadata的方法，返回的结果为一个字符串数组。
其中参数AnnotationMetadata内包含了被@Import注解的类的注解信息。
在selectImports方法内可根据具体实现决定返回哪些配置类的全限定名，
将结果以字符串数组的形式返回。比如：@EnableAutoConfiguration就被@Import注解了，导入了
AutoConfigurationImportSelector，AnnotationMetadata内就包含了@EnableAutoConfiguration
的信息，AutoConfigurationImportSelector会对这些信息做处理，以决定返回哪些配置类的全限定名。

如果实现了接口ImportSelector的类的同时又实现了以下4个Aware接口，
那么Spring保证在调用ImportSelector之前会先调用Aware接口的方法。
这4个接口为：EnvironmentAware、BeanFactoryAware、BeanClassLoaderAware和ResourceLoaderAware。

AutoConfigurationImportSelector并没有直接实现ImportSelector接口，
而是实现了它的子接口DeferredImportSelector。DeferredImportSelector接口与ImportSelector
的区别是，前者会在所有的@Configuration类加载完成之后再加载返回的配置类(这时可以排除一些不需要的
@Configuration类)，
而ImportSelector是在加载完@Configuration类之前先去加载返回的配置类。
DeferredImportSelector的加载顺序可以通过@Order注解或实现Ordered接口来指定。
同时，DeferredImportSelector提供了新的方法getImportGroup()来跨DeferredImportSelector实现自定义Configuration的加载顺序。
</pre>

### @EnableAutoConfiguration自动配置开关
- NOTE
<pre>检查自动配置是否开启的代码位于AutoConfigurationImportSelector的selectImports方法第一段中。
如果开启自动配置功能，就继续执行后续操作；如果未开启，就返回空数组。
通过isEnabled方法可以看出，如果当前类为AutoConfigurationImportSelector，
程序会从环境中获取key为EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY的配置，
该常量的值为spring.boot.enableautoconfiguration。如果获取不到该属性的配置，
isEnabled默认为true，也就是默认会使用自动配置。如果当前类为其他类，直接返回true。
如果想覆盖或重置EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY的配置，
可获取该常量的值，并在application.properties或application.yml中针对此参数进行配置。
以application.properties配置关闭自动配置为例：
spring.boot.enableautoconfiguration=false</pre>

### @EnableAutoConfiguration加载元数据配置
- NOTE
<pre>加载元数据配置主要是为后续操作提供数据支持。
该功能的代码依旧在AutoConfigurationImportSelector的selectImports方法内。
加载元数据的配置用到了AutoConfigurationMetadataLoader类提供的loadMetaData方法，
该方法会默认加载类路径下META-INF/spring-autoconfigure-metadata.properties内的配置。
spring-autoconfigure-metadata.properties文件内的配置格式如下：
自动配置类的全限定名.注解名称(条件)=值
为什么要加载此元数据呢？加载元数据主要是为了后续过滤自动配置使用。
Spring Boot使用一个Annotation的处理器来收集自动加载的条件，
这些条件可以在元数据文件中进行配置。Spring Boot会将收集好的@Configuration进行一次过滤，
进而剔除不满足条件的配置类。在官方文档中已经明确指出，
使用这种配置方式可以有效缩短Spring Boot的启动时间，减少@Configuration类的数量，
从而减少初始化Bean的耗时。
例子可以参考：MemberAutoConfiguration</pre>

### @EnableAutoConfiguration加载自动配置组件
- NOTE
<pre>加载自动配置组件是自动配置的核心组件之一，这些自动配置组件在类路径中META-INF目录下的
spring.factories文件中进行注册。Spring Boot预置了一部分常用组件，
如果我们需要创建自己的组件，可参考Spring Boot预置组件在自己的Starters中进行配置。
通过Spring Core提供的SpringFactoriesLoader类可以读取spring.factories文件中注册的类。
SpringFactoriesLoader加载器加载指定ClassLoader下面的所有META-INF/spring.factories文件，
并将文件解析内容存于Map&lt;String,List&lt;String&gt;&gt;内。
然后，通过loadFactoryNames传递过来的class的名称从Map中获得该类的配置列表。</pre>

### @EnableAutoConfiguration排除指定组件
- NOTE
<pre>我们获得了spring.factories文件中注册的自动加载组件，但如果在实际应用的过程中并不需要其中
的某个或某些组件，可通过配置@EnableAutoConfiguration的注解属性exclude或excludeName
进行有针对性的排除，当然也可以通过配置文件进行排除。
AutoConfigurationImportSelector中通过调用getExclusions方法来获取被排除类的集合。
以排除自动配置DataSourceAutoConfiguration为例，配置文件中的配置形式如下：
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
如果被排除类都符合条件，调用configurations.removeAll(exclusions)方法从自动配置集合中移除被排除集合的类，至此完成初步的自动配置组件排除。</pre>

### @EnableAutoConfiguration过滤自动配置组件
- NOTE
<pre>当完成初步的自动配置组件排除工作之后，AutoConfigurationImportSelector会结合在此之前获取
的AutoConfigurationMetadata对象，对自动配置组件列表进行再次过滤，
过滤条件为该列表中自动配置类的注解得包含在OnBeanCondition、
OnClassCondition和OnWebApplicationCondition中指定的注解，
依次包含@ConditionalOnBean、@ConditionalOnClass和@ConditionalOnWebApplication。</pre>

### @EnableAutoConfiguration事件注册
- NOTE
<pre>在完成了过滤、筛选之后，我们最终获得了要进行自动配置的类的集合，在将该集合返回之前，
在AutoConfigurationImportSelector类中完成的最后一步操作就是相关事件的封装和广播。
首先通过SpringFactoriesLoader类提供的loadFactories方法将spring.factories中配置的接口
AutoConfigurationImportListener的实现类加载出来。然后，将筛选出的自动配置类集合和被排除
的自动配置类集合封装成AutoConfigurationImportEvent事件对象，并传入该事件对象通过监听器
提供的onAutoConfigurationImportEvent方法，最后进行事件广播。</pre>

## spring\.factories
> leftSide=`true`

- NOTE
<pre>配置文件，位于jar包的META-INF目录下，按照指定格式注册了自动配置的AutoConfiguration类。
spring.factories也可以包含其他类型待注册的类。该配置文件不仅存在于Spring Boot项目中，
也可以存在于自定义的自动配置（或Starter）项目中。</pre>

## XxxAutoConfiguration
> leftSide=`true`

- NOTE
<pre>自动配置类，代表了Spring Boot中一类以XXAutoConfiguration命名的自动配置类。
其中定义了三方组件集成Spring所需初始化的Bean和条件。</pre>

## @Conditional
- NOTE
<pre>条件注解及其衍生注解，在AutoConfiguration类上使用，当满足该条件注解时才会实例化AutoConfiguration类。</pre>

## Starters
> leftSide=`true`

- NOTE
<pre>三方组件的依赖及配置，Spring Boot已经预置的组件。
SpringBoot默认的Starters项目往往只包含了一个pom依赖的项目。
如果是自定义的starter，该项目还需包含spring.factories文件、AutoConfiguration类和其他配置类。</pre>
