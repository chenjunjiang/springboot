Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Spring Boot消息
- NOTE
<pre>Spring框架对消息系统的整合提供了广泛的支持：从简单使用JmsTemplate的JMS API，
到可接收异步消息的完整基础结构。Spring AMQP为“高级消息队列协议”提供了类似的功能集。
同时，Spring Boot也为RabbitTemplate和Rabbit MQ提供了自动配置选项。
Spring Boot通过自动配置对ActiveMQ、RabbitMQ和Apache Kafka提供了支持。
本章重点讲解Spring Boot对JMS和ActiveMQ的自动配置操作。</pre>

## JMS基础自动配置
- NOTE
<pre>JMS的全称是Java Message Service，即Java消息服务。它主要用于在生产者和消费者之间进行消息
传递。JMS只是一个标准，在使用的时候需要有具体实现，比如ActiveMQ。在Spring Boot中，
通过JmsAutoConfiguration自动配置来完成JMS的基础组件的初始化。像其他自动配置一样，
在META-INF/spring.factories中可以找到注册的JMS自动配置类。
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration

1、JmsAutoConfiguration的注解
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Message.class, JmsTemplate.class })
@ConditionalOnBean(ConnectionFactory.class)
@EnableConfigurationProperties(JmsProperties.class)
@Import(JmsAnnotationDrivenConfiguration.class)
public class JmsAutoConfiguration {
}
@ConditionalOnClass注解指定需要满足在classpath下存在javax.jms.Message类和
org.springframework.jms.core.JmsTemplate类的条件才会进行初始化。@ConditionalOnBean
注解指定需要在容器中存在javax.jms.ConnectionFactory的Bean对象时才会被实例化。
ConnectionFactory接口提供了用于创建与JMS代理进行交互的javax.jms.Connection的标准方法。
Spring需要ConnectionFactory来与JMS一起使用，但是通常不需要编程人员直接使用它。
@EnableConfigurationProperties引入了JMS的配置属性类，对应的就是在application.properties
文件中配置的以“spring.jms”为前缀的属性。@Import引入了JmsAnnotationDrivenConfiguration
配置，该配置类主要用于Spring4.1注解驱动的JMS的自动配置。
@Configuration声明该类也是配置类，@ConditionalOnClass表示类路径下需存在EnableJms类。
其中EnableJms为一个注解类，@EnableJms用于开启JMS注解，使@JmsListener注解生效。



</pre>

## ActiveMQ自动配置
> leftSide=`true`

- NOTE
<pre>ActiveMQ是Apache提供的一个开源的消息系统，很好地支持了JMS规范。在使用ActiveMQ时需要
在pom文件中引入spring-boot-starter-activemq。ActiveMQ在Spring Boot的自动配置类注册
同样在META-INF/spring.factories中。
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration
ActiveMQAutoConfiguration类没有具体代码实现，主要通过注解完成功能的实现。
@Configuration(proxyBeanMethods = false)
@AutoConfigureBefore(JmsAutoConfiguration.class)
@AutoConfigureAfter({ JndiConnectionFactoryAutoConfiguration.class })
@ConditionalOnClass({ ConnectionFactory.class, ActiveMQConnectionFactory.class })
@ConditionalOnMissingBean(ConnectionFactory.class)
@EnableConfigurationProperties({ ActiveMQProperties.class, JmsProperties.class })
@Import({ ActiveMQXAConnectionFactoryConfiguration.class, ActiveMQConnectionFactoryConfiguration.class })
public class ActiveMQAutoConfiguration {
}
@AutoConfigureBefore注解指定该类需在JmsAutoConfiguration配置之前进行初始化。
前面我们已经讲过，JmsAutoConfiguration初始化时需要用到ActiveMQAutoConfiguration初始化
的ConnectionFactory，因此需要在JmsAutoConfiguration之前完成初始化。
@AutoConfigureAfter中指定了在JndiConnectionFactoryAutoConfiguration配置完成之后进行
初始化。JndiConnectionFactoryAutoConfiguration中主要通过JNDI的方式获得ConnectionFactory
实例。
</pre>

## @JmsListener注解解析
> leftSide=`true`

- NOTE
<pre>JMS消息分发送消息和接收消息两种功能，发送消息很简单，注入JmsTemplate到对应的Bean中
即可使用。接收消息则需要使用@JmsListener注解。
先看一下发送消息的官方示例：
@Component
public class MyBean{
    private final JmsTemplate jmsTemplate;
    
    @Autowired
    public MyBean(JmsTemplate jmsTemplate){
         this.jmsTemplate = jmsTemplate;
    }
    // ......
}

接收消息的官方代码示例如下：
@Component
public class MyBean{
    @JmsListener
    public void processMessage(String content){
        // ......
    }
}

当JMS的基础构件都完成初始化之后，可以使用@JmsListener注释任何Bean来创建侦听器端点
@JmsListener注解是由Spring提供的，它位于spring-jms包下。Spring会对注解了
@JmsListener的方法进行处理。在这一过程中主要使用到同一包下的
JmsListenerAnnotationBeanPostProcessor类。
</pre>
